% \iffalse meta-comment
%
%% File: l3doc.dtx
%
% Copyright (C) 1990-2023 The LaTeX Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "l3kernel bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/latex3
%
% for those people who are interested.
%
%<*driver>
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
\input docstrip %
\askforoverwritefalse
\preamble

Copyright (C) 1990-2023 The LaTeX Project

It may be distributed and/or modified under the conditions of
the LaTeX Project Public License (LPPL), either version 1.3c of
this license or (at your option) any later version.  The latest
version of this license is in the file:

   https://www.latex-project.org/lppl.txt

This file is part of the "l3kernel bundle" (The Work in LPPL)
and all files in that bundle must be distributed together.

\endpreamble
% stop docstrip adding \endinput
\postamble
\endpostamble
\generate{\file{l3doc.cls}{\from{l3doc-zh-cn.dtx}{class,cfg}}}
\generate{\file{l3doc.ist}{\from{l3doc-zh-cn.dtx}{docist}}}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</driver>
%
%<*driver|class>
\RequirePackage{calc}
%</driver|class>
%
%<*driver>
\PassOptionsToPackage{quiet}{fontspec}
\documentclass{l3doc}
\usepackage{framed}

% ^^A ================ 中文版特别设置 ============================
\usepackage[fontset=source]{ctex}
\ctexset{contentsname={\hfil 目\quad 录\hfil}}
\IndexPrologue
  {
    \section*{索引}
    \markboth{索引}{索引}
    \addcontentsline{toc}{section}{索引}
    斜体数字指向相应条目描述的页面，
    下划线数字指向定义的代码行，
    其它的都指向使用条目的页面。
  }
\makeatletter
\ExplSyntaxOn
\cs_set_protected:Npn \__codedoc_print_end_definition:
  {
    \seq_set_map:NNn \l__codedoc_tmpa_seq
      \g__codedoc_nested_names_seq
      { \__codedoc_macro_end_wrap_item:n {##1} }
      %%
    \int_compare:nTF { \seq_count:N \l__codedoc_tmpa_seq <= 3 }
      {
        \seq_use:Nnnn \l__codedoc_tmpa_seq
          { \,~和~ } { \,,~ } { \,,~和~ }
      }
      { \seq_item:Nn \l__codedoc_tmpa_seq {1}\,~以及其它的 }
    \@ 定义结束。
    \__codedoc_print_documented:
  }
\cs_set_protected:Npn \__codedoc_print_documented:
  {
    \seq_gset_filter:NNn \g__codedoc_nested_names_seq
      \g__codedoc_nested_names_seq
      {
        ! \bool_lazy_any_p:n
          {
            { \__codedoc_if_macro_internal_p:n {##1} }
            { \l__codedoc_macro_deprecated_bool }
            { \l__codedoc_macro_nodoc_bool }
          }
      }
    \seq_if_empty:NF \g__codedoc_nested_names_seq
      {
        \int_set:Nn \l__codedoc_tmpa_int
          { \seq_count:N \g__codedoc_nested_names_seq }
        \int_compare:nNnTF \l__codedoc_tmpa_int = 1 {这个} {这些}
        \bool_if:NTF \l__codedoc_macro_var_bool {变量} {函数}
        \int_compare:nNnTF \l__codedoc_tmpa_int = 1 {} {}
        被记录在第
        \__codedoc_get_hyper_target:eN
          { \seq_item:Nn \g__codedoc_nested_names_seq { 1 } }
          \l__codedoc_tmpa_tl
        \exp_args:Ne \pageref { \l__codedoc_tmpa_tl } 页。
      }
    \seq_gclear:N \g__codedoc_nested_names_seq
  }
\ExplSyntaxOff
\makeatother
% ^^A =================== 设置颜色 ===============================
\usepackage{xcolor}
\definecolor{spot}{HTML}{003399}
\definecolor{code}{HTML}{a25e26}
\definecolor{verb}{HTML}{007f00}
\let\OriginalMF\MacroFont
\def\MacroFont{\color{spot}\OriginalMF}
\makeatletter
\pretocmd{\macrocode}{\def\macro@font{\color{code}\OriginalMF}\def\MacroFont{\color{code}\OriginalMF}}{}{}
\makeatother
\AtBeginEnvironment{quote}{\color{verb}}
\AtBeginEnvironment{flushleft}{\tt\color{verb}}
\AtBeginEnvironment{verbatim}{\color{verb}\def\MacroFont{\color{verb}\OriginalMF}}
\ExplSyntaxOn
\pretocmd{\__codedoc_typeset_functions:}{\color{spot}\arrayrulecolor{spot}}{}{}
\patchcmd{\__codedoc_typeset_aux:n}{\color[gray]{0.5}}{\color{spot}}{}{}
\ExplSyntaxOff
\hypersetup{%
  colorlinks=true,
  linkcolor=spot,
  urlcolor=spot,
  citecolor=spot,
  bookmarksopen=false,
  bookmarksnumbered=false,
  plainpages=false}
% ^^A ================ 中文版设置结束 ============================

\begin{document}
  \DocInput{l3doc-zh-cn.dtx}
\end{document}
%</driver>
%
% This isn't included in the typeset documentation because it's a bit
% ugly:
%<*class>
\ProvidesExplClass{l3doc}{2023-12-11}{}
  {L3 Experimental documentation class}
%</class>
% \fi
%
% \title{\huge\bfseries\color{spot}\cls{l3doc} 文档类\Large\ —— 实验性质\thanks{%
%    根据广泛需求，我们现在发布了这个实验性的类文档。
%    但请注意，它绝不是最终版本，并且很有可能会经历修改，甚至是
%    \emph{不兼容的修改}！因此，如果类发生变化，可能需要进行更新才能继续使用。}}
%
% \author{}
% \date{
%   \begin{tabular}{c@{\hspace{\ccwd}}c@{\hspace{2\ccwd}}l}
%     \Team & 2023年12月11日 & 发布\\[6pt]
%     张泓知 & \zhtoday & 【译】
%   \end{tabular}
% }
% \maketitle
%
% \tableofcontents
%
% \begin{documentation}
%
%
% \section{介绍}
%
% 在 \pkg{doc} 从版本 2 变更为版本 3 之前编写了此类的代码和文档，这已经显示出这个类目前的落后程度。所以请认真对待以下警告：
%
%  \begin{quote}\color{red}
% \textbf{它的稳定性远不如主要的 \pkg{expl3} 包。\\
%   请自行承担风险！}
%  \end{quote}
%
% 这是一个专门用于记录 \pkg{expl3} 捆绑包的类，它是组成 \LaTeX3 编程环境的模块或包的集合。最终它将取代 \cls{ltxdoc} 类作为 \LaTeX3 的文档类，但在吸收 \pkg{hypdoc}、\cls{xdoc2}、\pkg{docmfp} 和 \cls{gmdoc} 中的优秀思想之前不会这样做。
%
% 它被编写为一个“自包含”的 docstrip 文件：执行 |latex l3doc.dtx| 将生成文件 \file{l3doc.cls} 并排版此文档；执行 |tex l3doc.dtx| 将只生成 \file{l3doc.cls}。
%
% \section{其他包的特性}
%
% 这个类基于 \pkg{ltxdoc} 类和 \pkg{doc} 宏包，但在它们最初编写之后，一些改进和替代方案出现了，我们希望能够借鉴这些新特性。
%
% 这些包或类有 \pkg{hypdoc}、\pkg{docmfp}、\pkg{gmdoc} 和 \pkg{xdoc}。我在下面对它们进行了总结，以便确定我们至少应该为 \pkg{l3doc} 设定什么样的最低特性。
%
% \subsection{\pkg{hypdoc} 包}
%
% 此包为 \pkg{doc} 包提供了超链接支持。我将它包含在此列表中是为了提醒我，文档和方法实现之间的交叉引用并不是很好。（例如，能够自动地从方法实现链接到其文档说明，反之亦然，将会很不错。）
%
% \subsection{\pkg{docmfp} 包}
%
% \begin{itemize}
%   \item 为 MetaFont 和 MetaPost 代码提供了 \cs{DescribeRoutine} 和 \env{routine} 环境（等等）。
%   \item 为更通用的代码提供了 \cs{DescribeVariable} 和 \env{variable} 环境（等等）。
%   \item 提供了 \cs{Describe} 和 \env{Code} 环境（等等）作为上述两个实例的一般化。
%   \item 对 DocStrip 系统进行了小的调整，以帮助非 \LaTeX{} 的使用。
% \end{itemize}
%
% \subsection{\pkg{xdoc2} 包}
%
% \begin{itemize}
%   \item 双面打印支持。
%   \item \cs{NewMacroEnvironment}、\cs{NewDescribeEnvironment}；与 \pkg{docmfp} 类似的概念但更全面。
%   \item 大量小改进。
% \end{itemize}
%
% \subsection{\pkg{gmdoc} 包}
%
% 将 \pkg{doc} 作为包或类进行了根本性的重新实现。
% \begin{itemize}
%   \item 不需要 |\begin{macrocode}| 块！
%   \item 自动插入 |\begin{macro}| 块！
%   \item 还有许多其他细微的改进。
% \end{itemize}
%
% \section{问题与待办事项}

% 目前存在的问题：
% (1)~对可以记录的内容类型不够灵活；
% (2)~|\begin{function}| 环境用于记录内容，与在实现中类似地使用的 |\begin{macro}| 函数之间没有明显的联系。

% 在用于实现部分时，\env{macro} 可能应该改名为 \env{function}。但在这种改名发生之前，它们应该具有相同的语法！

% 此外，我们需要另一层文档命令来处理“用户宏”与“代码函数”；\pkg{expl3} 函数可能需要不同的文档方式（至少在索引方面），
% 与 \pkg{ltcmd} 用户宏不同。

% 以下是一些待完成事项的列表，没有特定顺序：
% \begin{itemize}
%   \item 将 \env{function}/\env{macro} 环境重命名，以更好地描述其用途。
%   \item 普遍化 \env{function}/\env{macro}，用于记录“其他内容”，如环境名称、包选项，甚至键值选项。
%   \item 像 \tn{part} 一样新增一个用于文件的函数（删除笨拙的 \enquote{File} 作为 \tn{partname}）。
%   \item 寻找更好的替代方案来取代 \cs{StopEventually}；我考虑使用两个环境\hfil\break \env{documentation} 和 \env{implementation}，
%     它们可以有条件地排版/忽略其内容。（这已经被实现，但需要进一步考虑。）
%   \item 将宏的文档和实现进行超链接（参考 \pkg{svn-multi} v2 的 \textsc{dtx} 文件）。现在这部分已经部分完成，但需要改进。
% \end{itemize}
%
% \section{文档}
%
% \subsection{配置}
%
% 在处理类选项之前，\pkg{l3doc} 如果存在配置文件 \file{l3doc.cfg}，将加载它，
% 允许你在不必更改文档源文件的情况下定制类的行为。
%
% 例如，要在信纸大小的纸张上生成文档而不是默认的 A4 大小，创建 \file{l3doc.cfg}，
% 并包含以下内容：
% \begin{verbatim}
% \PassOptionsToClass{letterpaper}{l3doc}
% \end{verbatim}
%
% 默认情况下，\pkg{l3doc} 选择 |T1| 字体编码并加载 Latin Modern 字体。
% 要阻止这一行为，可以使用类选项 |cm-default|。
%
% \subsection{类选项}
%
% 该类识别了许多选项，其中一些是通常有用的，另一些则专门针对内核团队使用。
%
% \DescribeOption{full}
% \DescribeOption{onlydoc}
% 当设置 \texttt{full} 选项时（标准设置），源文件的文档和实现部分都会排版。
% 另一方面，如果设置了 \texttt{onlydoc} 选项，则只会排版文档部分。
%
% \DescribeOption{lm-default}
% 选择标准字体设置是在 \texttt{T1} 编码下的 Latin Modern（标准设置），
% 还是保持字体设置不变。
%
% \DescribeOption{kernel}
% 确定 \pkg{l3doc} 是否将 |\__kernel_| 命令和 |\(c|g|l)__kernel_| 变量视为代码中可接受的内容。
% 一般来说，不允许来自当前模块外部的内部内容。然而，为了引导 \pkg{expl3} 内核，
% 需要一些跨模块的功能。为了避免否则会出现的错误消息，可以使用类选项 \texttt{kernel}。
%
% \DescribeOption{check}
% 给定 \texttt{check} 选项时，类将记录在 \texttt{\meta{name}.cmds} 文件中定义和记录的所有命令。
% 这将显示哪些命令既被记录又被定义，哪些仅被记录，以及哪些仅被定义。
% （这里，“定义”指的是在源文件的实现部分使用 \texttt{macro} 或 \texttt{variable} 环境列出的命令。）
%
% \DescribeOption{checktest}
% 给定 \texttt{checktest} 选项时，类将检查源文件实现部分中的每个函数条目是否使用了 \cs{UnitTest} 进行了标记。
%
% \DescribeOption{show-notes}
% \DescribeOption{hide-notes}
% 这些互补选项确定是否打印使用 \cs{NB} 和 \cs{NOTE} 命令提供的信息。
%
% \DescribeOption{cs-break}
% \DescribeOption{cs-break-nohyphen}
% 命令 \cs{cmd} 和 \cs{cs} 允许在大多数下划线后进行连字符的处理。
% 默认情况下，会使用连字符标记连字符位置，但可以使用 \texttt{cs-break-nohyphen}
% 类选项进行更改。若要完全禁用控制序列的连字符处理，使用 \texttt{cs-break = false}。
%
% \subsection{文档和代码实现的分割}
%
% \pkg{doc} 使用 \cs{OnlyDocumentation}/\cs{AlsoImplementation} 宏来指导\hfil\break
% \cs{StopEventually}|{}| 的使用，该命令用于在单个 \file{.dtx} 文件中分隔文档和实现部分。
%
% 这并不十分灵活，因为它假定我们总是要打印文档部分。对于 \pkg{expl3} 源文件，
% 我希望能够以两种模式输入 \file{.dtx} 文件：只显示文档部分和只显示实现部分。
% 例如：
% \begin{verbatim}
% \DisableImplementation
% \DocInput{l3basics,l3prg,...}
% \EnableImplementation
% \DisableDocumentation
% \DocInputAgain
% \end{verbatim}
%
% \pkg{expl3}包的整个文档，包括实现部分在最后。这不是完美的，但是这是一个开始。
%
% 在文档部分使用 |\begin{documentation}...\end{documentation}|，
% 在实现部分使用 |\begin{implementation}...\end{implementation}|。
%
% \cs{EnableDocumentation}/\cs{EnableImplementation} 使其在 \file{.dtx} 文件
% \cs{DocInput} 时能够排版；使用 \cs{DisableDocumentation}/\cs{DisableImplementation}
% 可以省略这些环境的内容。
%
% 注意，\cs{DocInput} 现在接受逗号分隔的参数，并且 \cs{DocInputAgain}
% 可以重新输入以这种方式先前输入的所有 \file{.dtx} 文件。
%
% \subsection{一般文本标记}
%
% 本节中的许多命令来自于 \pkg{ltxdoc}，做了一些改进。
%
% \begin{function}{\cmd, \cs}
%   \begin{syntax}
%     \cmd{\cmd} \oarg{options} \meta{control sequence}\\
%     \cs{cs} \oarg{options} \marg{csname}
%   \end{syntax}
%   这些命令用于排版控制序列。|\cmd\foo| 生成 \enquote{\cmd\foo}，
%   而 |\cs{foo}| 也生成相同的效果。通常情况下，\cs{cs} 更健壮，
%   因为它不依赖于类别码是否 \enquote{正确}，因此更推荐使用。
%
%   这些命令知道 |@@| \pkg{l3docstrip} 语法，并正确替换文档中的这些实例。
%   这仅在 |%<@@=|\meta{module}|>| 声明之后发生。
%
%   此外，命令可以用在 \cs{cs} 的参数中。例如，
%   |\cs{\meta{name}:\meta{signature}}| 生成 \cs[no-index]{\meta{name}:\meta{signature}}。
%
%   \meta{选项} 是一个键值列表，可以包含以下键：
%   \begin{itemize}
%     \item |index=|\meta{name}：将 \meta{csname} 索引，就好像写了 \cs{cs}\Arg{name} 一样。
%     \item |no-index|：不索引 \meta{csname}。
%     \item |module=|\meta{module}：在 \meta{module} 的命令列表中索引 \meta{csname}；
%       特别的，\meta{module} 可以是 |TeX|，表示 \enquote{\TeX{} 和 \LaTeXe{}}
%       命令，或者为空，表示放在主索引中。默认情况下，\meta{module} 从命令名称中自动推断。
%     \item |replace| 是一个布尔键（默认为 \texttt{true}），表示是否像 \pkg{l3docstrip}
%       那样替换 |@@|。
%   \end{itemize}
%   这些命令允许在大多数下划线后进行连字符处理。
%   默认情况下，会使用连字符标记连字符位置，但可以使用 \texttt{cs-break-nohyphen}
%   类选项进行更改。若要完全禁用控制序列的连字符处理，使用 \texttt{cs-break = false}。
% \end{function}
%
%
% \begin{function}{\tn}
%   \begin{syntax}
%     \cs{tn} \oarg{options} \marg{csname}
%   \end{syntax}
%   与 \cs{cs} 类似，但用于“传统” \TeX{} 或 \LaTeXe{} 命令；它们会相应地进行索引。
%   实际上，这相当于 \cs{cs} |[module=TeX, replace=false,|
%   \meta{options}|]| \Arg{csname}。
% \end{function}
%
% \begin{function}{\meta}
%   \begin{syntax}
%     \cs{meta} \Arg{name}
%   \end{syntax}
%   \cs{meta} 以斜体在 \meta{angle brackets} 中排版 \meta{name}。
%   在 \env{function} 等环境中，尖括号 |<...>| 被设置为 |\meta{...}| 的简写。
%
%   与其 \pkg{ltxdoc} 版本相比，此函数有额外功能；下划线可以用于标记数学模式中的下标。
%   例如，|\meta{arg_{xy}}| 生成 \enquote{\meta{arg_{xy}}}。
% \end{function}
%
% \begin{function}{\Arg, \marg, \oarg, \parg}
%   \begin{syntax}
%     |\Arg| \Arg{name}
%   \end{syntax}
%   将 \meta{name} 以 \cs{meta} 的方式排版，并用大括号包裹。
%
%   \cs{marg}/\cs{oarg}/\cs{parg} 版本从 \pkg{ltxdoc} 派生，
%   分别用于 \LaTeXe{} 语法中的“必选”、“可选”或“图片”的括号形式。
% \end{function}
%
% \begin{function}{\file, \env, \pkg, \cls}
%   \begin{syntax}
%     \cs{pkg} \Arg{name}
%   \end{syntax}
%   这些命令都接受一个参数，用于表示文件、环境、包名和类名的语义命令。
% \end{function}
%
% \begin{function}{\NB, \NOTE}
%   \begin{syntax}
%     \cs{NB} \marg{tag} \marg{comments}
%     \verb|\begin{NOTE}| \marg{tag}
%     \qquad\meta{comments}
%     \verb|\end{NOTE}|
%   \end{syntax}
%   在源文件中做注释，默认情况下不进行排版。
%   当激活 \verb|show-notes| 类选项时，注释以非标记和抄录的方式排版。
% \end{function}
%
% \subsection{在文档中描述函数}
% 
% \DescribeEnv{function}
% \DescribeEnv{variable}
% 有两个经常使用的环境来描述 \pkg{expl3} 的函数和变量。如果描述一个变量，使用后者的环境；它与 \env{function} 环境的行为完全相同。
% \DescribeEnv{syntax}
% 通常，上述两个环境会与 \env{syntax} 环境结合使用，以描述它们的语法。
% \begin{framed}
%   \vspace{-\baselineskip}
% \begin{verbatim}
% \begin{function}{\package_function_one:N, \package_function_two:n}
%   \begin{syntax}
%     \cs{package_function_one:N} \meta{cs}
%     \cs{package_function_two:n} \marg{Argument}
%   \end{syntax}
% 这里是描述的文字 ...
% \end{function}
% \end{verbatim}
%   \hrulefill
%   \par
%   \hspace*{0.25\textwidth}
%   \begin{minipage}{0.5\textwidth}
%     \begin{function}{\package_function_one:N, \package_function_two:n}
%       \begin{syntax}
%         \cs[no-index]{package_function_one:N} \meta{cs}
%         \cs[no-index]{package_function_two:n} \marg{Argument}
%       \end{syntax}
%       \emph{这里是描述的文字 ...}
%     \end{function}
%   \end{minipage}
% \end{framed}
%
% 函数环境可以带有可选参数，表示所描述的函数是可展开的（使用|EXP|）、
% 受限可展开的（使用|rEXP|），或以条件形式定义（使用|TF|、|pTF|或|noTF|）。
% 注意，|pTF| 意味着 |EXP|，因为谓词必须始终是可展开的，
% 而|noTF|表示函数在没有|TF|的情况下应该另外进行文档化。对于条件形式|TF|
% 和|pTF|，\env{function}环境的参数实际上\emph{并不是}一个存在的命令：
% 在下面的示例中，\cs[no-index]{tl_if_empty:N}并不存在，
% 但它的条件形式\cs{tl_if_empty:NT}、\cs{tl_if_empty:NF}、\cs{tl_if_empty:NTF}，
% 以及谓词形式\cs{tl_if_empty_p:N}是存在的：
% \begin{framed}
%   \vspace{-\baselineskip}
% \begin{verbatim}
% \begin{function}[pTF]{\tl_if_empty:N, \tl_if_empty:c}
%   \begin{syntax}
%     \cs{tl_if_empty_p:N} \meta{tl~var}
%     \cs{tl_if_empty:NTF} \meta{tl~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   检查\meta{token list variable}是否完全为空（即不包含任何标记）。
% \end{function}
% \end{verbatim}
%   \hrulefill
%   \par
%   \hspace*{0.25\textwidth}
%   \begin{minipage}{0.5\textwidth}
%     \begin{function}[pTF]{\tl_if_empty:N, \tl_if_empty:c}
%       \begin{syntax}
%         \cs{tl_if_empty_p:N} \meta{tl~var}
%         \cs{tl_if_empty:NTF} \meta{tl~var} \Arg{true code} \Arg{false code}
%       \end{syntax}
%       检查\meta{token list variable}是否完全为空（即不包含任何标记）。
%     \end{function}
%   \end{minipage}
% \end{framed}
%
% \DescribeEnv{texnote}
% 这个环境用于突出显示仅对经验丰富的 \TeX{} 开发人员感兴趣的
% \env{function} 和类似环境中的部分内容。
%
% \subsection{描述实现中的函数}
%
% \DescribeEnv{macro}
% 在 \LaTeXe{} 中用于标记宏/函数实现的常用环境仍然是 \env{macro} 环境。
% 在 \pkg{l3doc} 中有一些变化：现在它接受逗号分隔的函数列表，
% 以避免大量连续的 |\end{macro}| 语句。
% 空格和换行被忽略（选项 |[verb]| 可以防止这种情况）。
% \begin{verbatim}
% % \begin{macro}{\foo:N, \foo:c}
% %   \begin{macrocode}
% ... code for \foo:N and \foo:c ...
% %   \end{macrocode}
% % \end{macro}
% \end{verbatim}
% 如果你正在文档化辅助宏，通常不需要如此突出它，
% 也不需要检查它是否具有测试函数，
% 是否在 \env{function} 环境中先有文档块。
% \pkg{l3doc} 将从名称中的 |__| 的存在或使用 |\begin{macro}[int]|
% 强制标记为内部来识别这些情况。
% 对于这些情况，边距标注将以灰色打印出来。
%
% 对于文档化 \pkg{expl3} 类型的条件语句，
% 你也可以在环境中传递 |TF| 选项（并从函数名称中省略它），
% 表示该函数提供了 |T|、|F| 和 |TF| 后缀。
% 类似的 |pTF| 选项会打印出 |TF| 和 |_p| 谓词形式。
% 选项 |noTF| 会打印出 |TF| 形式和既没有 |T| 也没有 |F| 的形式，
% 用于文档化诸如 \cs[no-index]{prop_get:NN} 这样也有条件形式的函数
% （\cs[no-index]{prop_get:NNTF}）。
%
% 在极少数情况下，一个“公共”函数没有用户文档。
% 在这些罕见情况下，可以添加选项 |no-user-doc| 来抑制未定义引用。
%
% \DescribeMacro{\TestFiles}
% \cs{TestFiles}\marg{文件列表} 用于指示当前代码使用的测试文件；
% 它们将在文档中打印出来。
%
% \DescribeMacro{\UnitTested}
% 在 \env{macro} 环境中，标记命令是否已创建单元测试是个好主意。
% 这可通过在 |\begin{macro}| ... |\end{macro}| 之间的任何位置写入
% \cs{UnitTested} 来表示。
%
% 如果启用了类选项 |checktest|，那么在没有调用 \file{Testfiles} 的
% \env{macro} 环境中会产生一个\emph{错误}。
% 这是为了像 \pkg{expl3} 这样的大型包设计的，这些包应该有完全详尽的测试套件，
% 其作者在添加新代码时可能不总是如应该般及时添加新测试。
%
% \DescribeMacro{\TestMissing}
% 如果一个函数缺少测试，可以通过写（需要多次）\cs{TestMissing} 
% \marg{explanation of test required} 来标记这些缺失的测试。
% 这些缺失的测试将在编译运行结束时的列表中进行总结打印。
%
% \DescribeEnv{variable}
% 在文档化变量定义时，使用 \env{variable} 环境代替。
% 它的行为与 \env{macro} 环境完全相同，只是如果启用了类选项 |checktest|，
% 则不需要为变量提供测试文件。
%
% \DescribeEnv{arguments}
% 在 \env{macro} 环境中，你可以使用 \env{arguments} 环境描述函数的参数。
% 它的行为类似于修改后的 enumerate 环境。
% \begin{verbatim}
% % \begin{macro}{\foo:nn, \foo:VV}
% % \begin{arguments}
% %   \item Name of froozle to be frazzled
% %   \item Name of muble to be jubled
% % \end{arguments}
% %   \begin{macrocode}
% ... code for \foo:nn and \foo:VV ...
% %   \end{macrocode}
% % \end{macro}
% \end{verbatim}
%
%
% \subsection{保持一致性}
%
% 每当使用 \env{function} 或 \env{macro} 文档化或定义一个函数时，
% 其名称都会存储在一个序列中以供以后处理。
%
% 在文档末尾（即在处理完 \file{.dtx} 文件之后），会分析名称列表，
% 检查是否所有已定义的函数都已经文档化，反之亦然。结果将打印在控制台输出中。
%
% 如果你需要对这些名称列表进行更严格的处理，
% 可以查看数据结构和用于直接存储和访问它们的方法的实现。
%
% \subsection{文档化模板}
%
% 提供以下宏用于文档化模板；可能最终会变成完全不同的内容，但谁知道呢。
% \begin{quote}\parskip=0pt\obeylines
%   |\begin{TemplateInterfaceDescription}| \Arg{template type name}
%   |  \TemplateArgument{none}{---}|
%   \textsc{或者一个或多个这些：}
%   |  \TemplateArgument| \Arg{arg no} \Arg{meaning}
%   \textsc{和}
%   |\TemplateSemantics|
%   |  | \meta{text describing the template type semantics}
%   |\end{TemplateInterfaceDescription}|
% \end{quote}
%
% \begin{quote}\parskip=0pt\obeylines
%   |\begin{TemplateDescription}| \Arg{template type name} \Arg{name}
%   \textsc{一个或多个这些：}
%   |  \TemplateKey| \marg{key name} \marg{type of key}
%   |    |\marg{textual description of meaning}
%   |    |\marg{default value if any}
%   \textsc{和}
%   |\TemplateSemantics|
%   |  | \meta{text describing special additional semantics of the template}
%   |\end{TemplateDescription}|
% \end{quote}
%
% \begin{quote}\parskip=0pt\obeylines
%   |\begin{InstanceDescription}| \oarg{text to specify key column width (optional)}
%   \hfill\marg{template type name}\marg{instance name}\marg{template name}
%   \textsc{一个或多个这些：}
%   |  \InstanceKey| \marg{key name} \marg{value}
%   \textsc{和}
%   |\InstanceSemantics|
%   |  | \meta{text describing the result of this instance}
%   |\end{InstanceDescription}|
% \end{quote}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3doc} 代码实现}
%
%    \begin{macrocode}
%<*class>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=codedoc>
%    \end{macrocode}
%
% \subsection{变量}
%
% \begin{variable}{\g_docinput_clist}
%   通过 \cs{DocInput} 输入的文件列表。
%    \begin{macrocode}
\clist_new:N \g_docinput_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_doc_functions_seq, \g_doc_macros_seq}
%   通过 \env{function} 文档化的所有函数和通过 \env{macro} 引入的所有宏。
%   可以进行比较，查看文档或代码缺失的部分。
%    \begin{macrocode}
\seq_new:N \g_doc_functions_seq
\seq_new:N \g_doc_macros_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_detect_internals_bool, \l_@@_detect_internals_tl}
%   如果为 \texttt{true}，\pkg{l3doc} 将检查在 \texttt{macro} 环境的参数中，
%   以及在 \texttt{macrocode} 环境中排版的代码中使用其他包中的内部命令
%   \cs[no-index]{__\meta{pkg}_\ldots{}}，但不包括在~\cs{cs} 中。
%   还有一个记载临时数据的记号列表用于此目的。
%    \begin{macrocode}
\bool_new:N \l_@@_detect_internals_bool
\bool_set_true:N \l_@@_detect_internals_bool
\tl_new:N \l_@@_detect_internals_tl
\tl_new:N \l_@@_detect_internals_cs_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_output_coffin}
%   \env{function} 环境通过将包含各种部分（函数名称、描述、\emph{等等}）
%   的线槺组合成一个线槺来排版。
%    \begin{macrocode}
\coffin_new:N \l_@@_output_coffin
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {\l_@@_functions_coffin, \l_@@_descr_coffin, \l_@@_syntax_coffin}
%   这些线槺分别包含函数名称列表（\env{function} 环境的参数）、
%   |\begin{function}| 和 |\end{function}| 之间的文本，
%   以及在 \env{syntax} 环境中给出的语法。
%    \begin{macrocode}
\coffin_new:N \l_@@_functions_coffin
\coffin_new:N \l_@@_descr_coffin
\coffin_new:N \l_@@_syntax_coffin
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_syntax_box}
%   在转移到 \cs{l_@@_syntax_coffin} 之前，\env{syntax} 环境的内容被排版在这个盒子中。
%    \begin{macrocode}
\box_new:N \g_@@_syntax_box
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_in_function_bool}
%   当在 \texttt{function} 或 \texttt{variable} 环境中时为真。
%   被 \texttt{syntax} 环境用于确定其行为。
%    \begin{macrocode}
\bool_new:N \l_@@_in_function_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_long_name_bool, \l_@@_trial_width_dim}
%   如果线槺 \cs{l_@@_functions_coffin}（包含当前函数名称）的宽度
%   \cs{l_@@_trial_width_dim} 大于边距中可用的空间，则布尔值
%   \cs{l_@@_long_name_bool} 为 \texttt{true}。
%    \begin{macrocode}
\bool_new:N \l_@@_long_name_bool
\dim_new:N \l_@@_trial_width_dim
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_nested_macro_int}
%   \env{macro} 环境的嵌套层级（在 \env{macro} 环境外现在为~$0$）。
%    \begin{macrocode}
\int_new:N \l_@@_nested_macro_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_macro_tested_bool,
%     \g_@@_missing_tests_prop,
%     \g_@@_not_tested_seq,
%     \g_@@_testfiles_seq,
%   }
%   一个布尔值，描述当前宏是否有测试，并且一些全局结构包含了关于测试文件以及
%   哪些测试缺失的信息。
%    \begin{macrocode}
\bool_new:N \l_@@_macro_tested_bool
\prop_new:N \g_@@_missing_tests_prop
\seq_new:N \g_@@_not_tested_seq
\seq_new:N \g_@@_testfiles_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_macro_deprecated_bool ,
%     \l_@@_macro_internal_bool,
%     \l_@@_macro_nodoc_bool ,
%     \l_@@_macro_TF_bool,
%     \l_@@_macro_pTF_bool,
%     \l_@@_macro_noTF_bool,
%     \l_@@_macro_EXP_bool,
%     \l_@@_macro_rEXP_bool,
%     \l_@@_macro_var_bool,
%     \l_@@_override_module_tl,
%     \l_@@_macro_documented_tl,
%   }
%   包含有关函数/宏环境某些选项的信息。我们初始化 \cs{l_@@_override_module_tl}
%   以避免通过空名称（表示无模块）覆盖模块名称。
%    \begin{macrocode}
\bool_new:N \l_@@_macro_deprecated_bool
\bool_new:N \l_@@_macro_internal_bool
\bool_new:N \l_@@_macro_nodoc_bool
\bool_new:N \l_@@_macro_TF_bool
\bool_new:N \l_@@_macro_pTF_bool
\bool_new:N \l_@@_macro_noTF_bool
\bool_new:N \l_@@_macro_EXP_bool
\bool_new:N \l_@@_macro_rEXP_bool
\bool_new:N \l_@@_macro_var_bool
\tl_new:N \l_@@_override_module_tl
\tl_set:Nn \l_@@_override_module_tl { \q_no_value }
\tl_new:N \l_@@_macro_documented_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_lmodern_bool,
%     \g_@@_checkfunc_bool,
%     \g_@@_checktest_bool,
%     \g_@@_cs_break_bool,
%     \g_@@_show_notes_bool,
%     \g_@@_kernel_bool
%   }
%   关于包选项的信息。
%    \begin{macrocode}
\bool_new:N \g_@@_lmodern_bool
\bool_new:N \g_@@_checkfunc_bool
\bool_new:N \g_@@_checktest_bool
\bool_new:N \g_@@_kernel_bool
\bool_new:N \g_@@_cs_break_bool
\bool_new:N \g_@@_show_notes_bool
\bool_gset_true:N \g_@@_cs_break_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_tmpa_tl, \l_@@_tmpb_tl, \l_@@_tmpa_int, \l_@@_tmpa_seq}
%   一些临时变量。
%    \begin{macrocode}
\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
\int_new:N \l_@@_tmpa_int
\int_new:N \l_@@_tmpa_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_names_block_tl}
%   本地序列变量列表（通过 \cs{@@_lseq_name:n} 生成），
%   每个都对应于 \env{function} 或 \env{macro} 环境中一组变体。
%   更准确地说，这些序列以基本形式命名，如 \cs{clist_count:n}
%   或 \cs{clist_count:N}（它们不是变体）。每个序列都有基本名称
%   （没有任何签名）作为其第一项，后跟变体签名的列表，
%   或者使用 \cs{scan_stop:} 表示无签名（无冒号）。
%    \begin{macrocode}
\tl_new:N \l_@@_names_block_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_variants_seq}
%   暂时存储正在文档化的函数/宏的变体列表（仅签名）。
%   它是全局的，因为我们需要在对齐的单元格中保持其值。
%    \begin{macrocode}
\seq_new:N \g_@@_variants_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_names_verb_bool}
%   如果宏/函数环境的主参数应该保留原样，不移除任何逗号或空格，则设置为 |true|。
%    \begin{macrocode}
\bool_new:N \l_@@_names_verb_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_names_seq}
%   函数/环境等作为给定 \env{function} 或 \env{macro} 环境参数出现的名称列表。
%   这些名称经过 |_@@| 和 |@@| 转换为 |__|\meta{module name} 和其他清理。
%    \begin{macrocode}
\seq_new:N \l_@@_names_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_nested_names_seq}
%   收集所有嵌套 \env{macro} 环境中的宏，以在“End definition”文本中使用。
%    \begin{macrocode}
\seq_new:N \g_@@_nested_names_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_index_macro_tl, \l_@@_index_key_tl,
%     \l_@@_index_module_tl, \l_@@_index_internal_bool,
%     \l_@@_macro_do_not_index_tl
%   }
%   当分析 \env{macrocode} 环境中发现的控制序列时，
%   \cs{l_@@_index_macro_tl} 保存控制序列（部分为字符串），
%   \cs{l_@@_index_key_tl} 保存索引中的未来排序键，
%   \cs{l_@@_index_module_tl} 是控制序列应该列入的子索引。
%   \cs{l_@@_index_internal_bool} 表示控制序列是内部的，
%   应在略微不同的子索引中索引。
%   最后，\cs{l_@@_macro_do_not_index_tl} 表示不应在特定 \env{macro} 环境中索引的控制序列。
%    \begin{macrocode}
\tl_new:N \l_@@_index_macro_tl
\tl_new:N \l_@@_index_key_tl
\tl_new:N \l_@@_index_module_tl
\tl_new:N \l_@@_macro_do_not_index_tl
\bool_new:N \l_@@_index_internal_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_module_name_tl}
%   模块名称，在读取行 |<@@=|\meta{module}|>| 时设置。
%    \begin{macrocode}
\tl_new:N \g_@@_module_name_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_@@_iow_rule_tl, \c_@@_iow_midrule_tl}
%   $40$ 个等号。
%    \begin{macrocode}
\tl_const:Nn \c_@@_iow_rule_tl
  { ======================================== }
\tl_const:Nn \c_@@_iow_mid_rule_tl
  { -------------------------------------- }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {\l_@@_macro_box, \l_@@_macro_index_box, \l_@@_macro_int}
%   用于储存宏环境中给定的名称的垂直盒子，
%   储存索引命令创建的目标的水平盒子，
%   以及到目前为止的宏数量（包括周围 \env{macro} 环境中的宏）。
%    \begin{macrocode}
\box_new:N \l_@@_macro_box
\box_new:N \l_@@_macro_index_box
\int_new:N \l_@@_macro_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_cmd_tl,
%     \l_@@_cmd_index_tl,
%     \l_@@_cmd_module_tl,
%     \l_@@_cmd_noindex_bool,
%     \l_@@_cmd_replace_bool,
%   }
%   用于控制 \cs{cmd}、\cs{cs} 和 \cs{tn} 行为的变量。
%    \begin{macrocode}
\tl_new:N \l_@@_cmd_tl
\tl_new:N \l_@@_cmd_index_tl
\tl_new:N \l_@@_cmd_module_tl
\bool_new:N \l_@@_cmd_noindex_bool
\bool_new:N \l_@@_cmd_replace_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_in_implementation_bool}
%   在 \env{implementation} 环境内为 \texttt{true}，其他地方为 \texttt{false}。
%    \begin{macrocode}
\bool_new:N \l_@@_in_implementation_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_typeset_documentation_bool,
%     \g_@@_typeset_implementation_bool
%   }
%   控制是否排版文档/实现的布尔值。默认情况下，两者都应为真。
%    \begin{macrocode}
\bool_new:N \g_@@_typeset_documentation_bool
\bool_new:N \g_@@_typeset_implementation_bool
\bool_set_true:N \g_@@_typeset_documentation_bool
\bool_set_true:N \g_@@_typeset_implementation_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_base_name_tl, \l_@@_variants_prop}
%   正在文档化的宏名称（不带签名），以及将变体的基本形式映射到具有相同基本形式的所有变体的属性列表。
%    \begin{macrocode}
\tl_new:N \g_@@_base_name_tl
\prop_new:N \l_@@_variants_prop
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_function_label_clist, \l_@@_no_label_bool}
%   \env{function} 环境的选项，用于替换给定控制序列列表的标签，
%   通常情况下标签会被多次插入函数文档，这样可以避免重复标签。
%    \begin{macrocode}
\clist_new:N \l_@@_function_label_clist
\bool_new:N \l_@@_no_label_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_date_added_tl, \l_@@_date_updated_tl}
%   \env{function} 环境选项的值。
%    \begin{macrocode}
\tl_new:N \l_@@_date_added_tl
\tl_new:N \l_@@_date_updated_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_macro_argument_tl}
%   保存 \env{macro} 或 \env{function} 环境的参数，以便在错误消息中使用。
%    \begin{macrocode}
\tl_new:N \l_@@_macro_argument_tl
%    \end{macrocode}
% \end{variable}
%
% ^^A Bruno: what does the next line do?
%    \begin{macrocode}
% \int_new:N \c@CodelineNo
%    \end{macrocode}
%
% \subsection{变量和辅助函数}
%
% \begin{macro}{\@@_tmpa:w, \@@_tmpb:w}
%   用于临时使用的辅助宏。
%    \begin{macrocode}
\cs_new_eq:NN \@@_tmpa:w ?
\cs_new_eq:NN \@@_tmpb:w ?
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \seq_set_split:NoV,
%     \tl_to_str:f
%   }
%   一些缺失的变体。
%    \begin{macrocode}
\cs_generate_variant:Nn \seq_set_split:Nnn { NoV }
\cs_generate_variant:Nn \tl_to_str:n { f }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{\@@_if_almost_str:n}
%   用于测试 |\cmd| 或其他要索引的宏的参数是否几乎是字符串：
%   例如，如果 |#1| 包含 |\meta{...}|，则为 \texttt{false}。
%   意外的 |f| 展开是为了处理以 \cs{c_backslash_str} 开头的 |#1|，
%   应该被展开并视为“正常”。
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_if_almost_str:n #1 { TF , T , F }
  {
    \int_compare:nNnTF
      { \tl_count:n {#1} }
      < { \tl_count:e { \tl_to_str:f {#1} } }
      { \prg_return_false: }
      { \prg_return_true: }
  }
\prg_generate_conditional_variant:Nnn \@@_if_almost_str:n { V } { T }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_trim_right:Nn, \@@_trim_right:No}
%   在 token 列表变量 ~|#1| 中移除 |#2| 后的所有内容。
%   可能与 \cs{@@_key_trim_module:n} 结合使用？
%    \begin{macrocode}
\cs_new_protected:Npn \@@_trim_right:Nn #1#2
  {
    \cs_set:Npn \@@_tmp:w ##1 #2 ##2 \q_stop { \exp_not:n {##1} }
    \__kernel_tl_set:Ne #1 { \exp_after:wN \@@_tmp:w #1 #2 \q_stop }
  }
\cs_generate_variant:Nn \@@_trim_right:Nn { No }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{\@@_str_if_begin:nn, \@@_str_if_begin:oo}
%   如果第一个字符串以第二个字符串开头，则为真。
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_str_if_begin:nn #1#2 { TF , T , F }
  {
    \tl_if_in:ooTF
      { \exp_after:wN \scan_stop: \tl_to_str:n {#1} }
      { \exp_after:wN \scan_stop: \tl_to_str:n {#2} }
      { \prg_return_true: }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn \@@_str_if_begin:nn
  { oo } { TF , T , F }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_replace_at_at:N}
% \begin{macro}{\@@_replace_at_at_aux:Nn}
%   目标是将 |@@| 替换为当前模块名称。我们利用此函数还可检测内部宏。
%   如果没有 \meta{module~name}，则不执行任何操作。
%   否则，规范化 |@| 和 |_| 的分类码，临时将 |@@@@| 更改为具有不同分类码的 |aa|，
%   稍后变为 |@@|，并将 |__@@|、|_@@| 和 |@@| 替换为 |__|\meta{module~name}。
%   结果中包含带有字母分类码的 |_|，因为这是 |macrocode| 环境的预期。
%   其他用例可通过 \cs{tl_to_str:n} 应用。
%   注意，下面的代码中包括 |@| 之间的空格，因为它也经过相同的替换规则处理。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_replace_at_at:N #1
  {
    \tl_if_empty:NF \g_@@_module_name_tl
      {
        \exp_args:NNo \@@_replace_at_at_aux:Nn
          #1 \g_@@_module_name_tl
      }
  }
\cs_new_protected:Npe \@@_replace_at_at_aux:Nn #1#2
  {
    \tl_replace_all:Nnn #1 { \token_to_str:N @ } { @ }
    \tl_replace_all:Nnn #1 { \token_to_str:N _ } { _ }
    \tl_replace_all:Nnn #1 { @ @ @ @ } { \token_to_str:N a a }
    \tl_replace_all:Nnn #1 { _ _ @ @ } { _ _ #2 }
    \tl_replace_all:Nnn #1 {   _ @ @ } { _ _ #2 }
    \tl_replace_all:Nnn #1 {     @ @ } { _ _ #2 }
    \tl_replace_all:Nnn #1 { \token_to_str:N a a } { @ @ }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_detect_internals:N,
%     \@@_detect_internals_aux:N,
%     \@@_if_detect_internals_ok:NF
%   }
%   在每个 |__| 处分割后，移除序列的开头项目（因为它不是跟在 |__| 后面），
%   移除任何空格或行尾后的所有内容，以得到控制序列的良好近似（用于警告消息）。
%   然后检查该序列是否以允许的内容开头：
%   |@@| 模块名称和 |:| 或 |_|，或者相关的布尔值设置为 |kernel_|（似乎可以安全地假设我们不会定义 |\__kernel:...| 命令）。
%   对于消息本身，移除任何 |_| 或 |:| 后的所有内容（具有任一分类码），
%   以获得模块名称的猜测。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_detect_internals:N #1
  {
    \bool_if:NT \l_@@_detect_internals_bool
      { \@@_detect_internals_aux:N #1 }
  }
\group_begin:
  \char_set_catcode_active:N \^^M
  \cs_new_protected:Npn \@@_detect_internals_aux:N #1
    {
      \tl_set_eq:NN \l_@@_detect_internals_tl #1
      \tl_replace_all:NVn \l_@@_detect_internals_tl \c_underscore_str { _ }
      \seq_set_split:NnV \l_@@_tmpa_seq { _ _ } \l_@@_detect_internals_tl
      \seq_pop_left:NN \l_@@_tmpa_seq \l_@@_detect_internals_tl
      \seq_map_variable:NNn \l_@@_tmpa_seq \l_@@_detect_internals_tl
        {
          \@@_trim_right:No \l_@@_detect_internals_tl
            \c_catcode_active_space_tl
          \@@_trim_right:Nn \l_@@_detect_internals_tl ^^M
          \@@_if_detect_internals_ok:NF \l_@@_detect_internals_tl
            {
              \tl_set_eq:NN \l_@@_detect_internals_cs_tl \l_@@_detect_internals_tl
              \@@_trim_right:Nn \l_@@_detect_internals_tl _
              \@@_trim_right:Nn \l_@@_detect_internals_tl :
              \@@_trim_right:No \l_@@_detect_internals_tl { \token_to_str:N : }
              \msg_warning:nneee { l3doc } { foreign-internal }
                { \tl_to_str:N \l_@@_detect_internals_cs_tl }
                { \tl_to_str:N \l_@@_detect_internals_tl }
                { \tl_to_str:N \g_@@_module_name_tl }
            }
        }
    }
\group_end:
\prg_new_protected_conditional:Npnn \@@_if_detect_internals_ok:N #1 { F }
  {
    \@@_str_if_begin:ooTF {#1} { \g_@@_module_name_tl _ }
      { \prg_return_true: }
      {
        \@@_str_if_begin:ooTF {#1} { \g_@@_module_name_tl : }
          { \prg_return_true: }
          {
            \bool_if:NTF \g_@@_kernel_bool
              {
                \@@_str_if_begin:ooTF {#1} { kernel _ }
                  { \prg_return_true: }
                  { \prg_return_false: }
              }
              { \prg_return_false: }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[rEXP]{\@@_signature_base_form:n}
% \begin{macro}
%   {\@@_signature_base_form_aux:n, \@@_signature_base_form_aux:w}
%   扩展为签名的“基本形式”。例如，对于 |noxcfvV|，将得到 |nnnNnnn|，
%   或对于 |ow|，将得到 |nw|。循环停在第一个无法识别的令牌处；
%   其余部分被封装在 \cs{exp_not:n} 中。
%    \begin{macrocode}
\cs_new:Npn \@@_signature_base_form:n #1
  { \@@_signature_base_form_aux:n #1 \q_stop }
\cs_new:Npn \@@_signature_base_form_aux:n #1
  {
    \str_case:nnTF {#1}
      {
        { N } { N }
        { c } { N }
        { n } { n }
        { o } { n }
        { f } { n }
        { e } { n }
        { x } { n }
        { V } { n }
        { v } { n }
      }
      { \@@_signature_base_form_aux:n }
      { \@@_signature_base_form_aux:w #1 }
  }
\cs_new:Npn \@@_signature_base_form_aux:w #1 \q_stop
  { \exp_not:n {#1} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_predicate_from_base:n}
%   从函数的基本名称获取谓词。代码不受没有签名的函数影响。
%   |n| 类型的版本可用于键和其他非控制序列。
%   在 |e|-展开后的输出是一个字符串。
%    \begin{macrocode}
\cs_new:Npn \@@_predicate_from_base:n #1
  {
    \@@_get_function_name:n {#1}
    \tl_to_str:n { _p: }
    \@@_get_function_signature:n {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_split_function_do:nn, \@@_split_function_do:on}
% \begin{macro}{\@@_get_function_name:n, \@@_get_function_signature:n}
% \begin{macro}{\@@_split_function_auxi:w, \@@_split_function_auxii:w}
%   类似于 \pkg{l3basics} 中定义的内部函数，但在这里我们直接在字符串上操作，
%   而不是控制序列。
%    \begin{macrocode}
\cs_new:Npn \@@_get_function_name:n #1
  { \@@_split_function_do:nn {#1} { \use_i:nnn } }
\cs_new:Npn \@@_get_function_signature:n #1
  { \@@_split_function_do:nn {#1} { \use_ii:nnn } }
\cs_set_protected:Npn \@@_tmpa:w #1
  {
    \cs_new:Npn \@@_split_function_do:nn ##1
      {
        \exp_after:wN \@@_split_function_auxi:w
        \tl_to_str:n {##1} \q_mark \c_true_bool
        #1 \q_mark \c_false_bool
        \q_stop
      }
    \cs_new:Npn \@@_split_function_auxi:w
      ##1 #1 ##2 \q_mark ##3##4 \q_stop ##5
      { \@@_split_function_auxii:w {##5} ##1 \q_mark \q_stop {##2} ##3 }
    \cs_new:Npn \@@_split_function_auxii:w
      ##1##2 \q_mark ##3 \q_stop
      { ##1 {##2} }
  }
\exp_args:No \@@_tmpa:w { \token_to_str:N : }
\cs_generate_variant:Nn \@@_split_function_do:nn { o }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[rEXP]{\@@_key_get_base:nN}
%   获取函数的基本形式并存储。作为获取基本形式的一部分，
%   将尾部的 |T| 或 |F| 更改为 |TF|，如果函数不包含冒号，
%   则跳过此更改，以避免更改一些以 \texttt{PDF} 结尾或类似结尾的名称。
%   各种字母 |z| 作为不同于 \cs{tl_to_str:n} 任何结果的终止符。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_key_get_base:nN #1#2
  {
    \@@_if_almost_str:nTF {#1}
      {
        \@@_key_get_base_TF:nN {#1} \l_@@_tmpa_tl
        \__kernel_tl_set:Ne #2
          { \@@_split_function_do:on \l_@@_tmpa_tl { \@@_base_form_aux:nnN } }
      }
      { \tl_set:Nn #2 {#1} }
  }
\cs_new:Npe \@@_key_get_base_TF:nN #1#2
  {
    \__kernel_tl_set:Ne #2 { \exp_not:N \tl_to_str:n {#1} }
    \tl_if_in:NoF #2 { \tl_to_str:n {:} }
      { \exp_not:N \prg_break: }
    \tl_if_in:onT { #2 z } { \tl_to_str:n {TF} z }
      { \exp_not:N \prg_break: }
    \tl_if_in:onT { #2 z } { \tl_to_str:n {T} z }
      {
        \tl_put_right:Nn #2 { \tl_to_str:n {F} }
        \exp_not:N \prg_break:
      }
    \tl_if_in:onT { #2 z } { \tl_to_str:n {F} z }
      {
        \tl_put_right:Nn #2 { z }
        \tl_replace_once:Nnn #2 { \tl_to_str:n {F} z } { \tl_to_str:n {TF} }
        \exp_not:N \prg_break:
      }
    \exp_not:N \prg_break_point:
  }
\cs_new:Npn \@@_base_form_aux:nnN #1#2#3
  {
    \exp_not:n {#1}
    \bool_if:NT #3
      {
        \token_to_str:N :
        \bool_lazy_or:nnTF
            { \str_if_eq_p:nn { #1 ~ } { \exp_args } }
            { \str_if_eq_p:nn { #1 ~ } { \exp_last_unbraced } }
          { \exp_not:n {#2} }
          { \@@_signature_base_form:n {#2} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_base_form_signature_do:nnn}
%   如果没有签名，或者 |#1| 中包含连续两个冒号（这包括奇怪的函数 |\::N| 等），
%   则执行 |#2{#1}|。否则，应用 |#3|，并使用以下两个参数：|#1| 的基本形式，
%   以及原始签名和额外的一对大括号。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_base_form_signature_do:nnn #1#2#3
  {
    \@@_split_function_do:nn {#1}
      { \@@_base_form_aux:nnnnnN {#1} {#2} {#3} }
  }
\cs_new_protected:Npn \@@_base_form_aux:nnnnnN #1#2#3#4#5#6
  {
    \bool_if:NTF #6
      {
        \tl_if_head_eq_charcode:nNTF {#4} :
          { #2 {#1} }
          {
            \use:e
              {
                \exp_not:n {#3}
                { \@@_base_form_aux:nnN {#4} {#5} #6 }
              }
                {#4} {#5}
          }
      }
      { #2 {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\@@_date_compare:nNn}
% \begin{macro}{\@@_date_compare_aux:nnnNnnn, \@@_date_compare_aux:w}
%   假设 |#1| 和 |#3| 是格式为 YYYY-MM-DD 的日期（也接受 YYYY 或 YYYY-MM）。
%   使用 |#2|（其中之一为 |<|、|=| 或 |>|）进行比较，对缺失数据填充零。
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_date_compare:nNn #1#2#3 { TF , T , F , p }
  { \@@_date_compare_aux:w #1--- \q_mark #2 #3--- \q_stop }
\cs_new:Npn \@@_date_compare_aux:w
    #1 - #2 - #3 - #4 \q_mark #5 #6 - #7 - #8 - #9 \q_stop
  {
    \@@_date_compare_aux:nnnNnnn
      { \tl_if_empty:nTF {#1} { 0 } {#1} }
      { \tl_if_empty:nTF {#2} { 0 } {#2} }
      { \tl_if_empty:nTF {#3} { 0 } {#3} }
      #5
      { \tl_if_empty:nTF {#6} { 0 } {#6} }
      { \tl_if_empty:nTF {#7} { 0 } {#7} }
      { \tl_if_empty:nTF {#8} { 0 } {#8} }
  }
\cs_new:Npn \@@_date_compare_aux:nnnNnnn #1#2#3#4#5#6#7
  {
    \int_compare:nNnTF {#1} = {#5}
      {
        \int_compare:nNnTF {#2} = {#6}
          {
            \int_compare:nNnTF {#3} #4 {#7}
              { \prg_return_true: } { \prg_return_false: }
          }
          {
            \int_compare:nNnTF {#2} #4 {#6}
              { \prg_return_true: } { \prg_return_false: }
          }
      }
      {
        \int_compare:nNnTF {#1} #4 {#5}
          { \prg_return_true: } { \prg_return_false: }
      }
    \use_none:n
    \q_stop
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_gprop_name:n, \@@_lseq_name:n}
%   我们需要跟踪一些有关正在（或已经）文档化的控制序列（和其他字符串）的信息。
%   一些信息存储在全局属性中，一些存储在本地序列中，
%   其名称不遵循惯例：它是 \cs[no-index]{g_@@} 或 \cs[no-index]{l_@@}，
%   后面跟着一个空格和字符串，这个字符串可以是任意的。
%   由于速度原因，我们不能合理地使用一个大的 |prop|。
%    \begin{macrocode}
\cs_new:Npn \@@_gprop_name:n #1 { g_@@ ~ \tl_to_str:n {#1} }
\cs_new:Npn \@@_lseq_name:n #1 { l_@@ ~ \tl_to_str:n {#1} }
%    \end{macrocode}
% \end{macro}
%
% \subsection{信息}
%
%    \begin{macrocode}
\msg_new:nnnn { l3doc } { no-signature-TF }
  { Function/macro~'#1'~cannot~be~turned~into~a~conditional. }
  {
    A~function~or~macro~environment~with~option~pTF,~TF~or~noTF~
    received~the~argument~'#1'.~This~function's~name~has~no~
    ':'~hence~it~is~not~clear~where~to~add~'_p'~or~'TF'.~
    Please~follow~expl3~naming~conventions.
  }
\msg_new:nnn { l3doc } { date-format }
  { The~date~'#1'~should~be~given~in~YYYY-MM-DD~format. }
\msg_new:nnn { l3doc } { future-date }
  { The~added/updated~date~'#2'~of~'#1'~is~in~the~future. }
\msg_new:nnn { l3doc } { syntax-nested-function }
  {
    The~'syntax'~environment~should~be~used~in~the~
    innermost~'function'~environment.
  }
\msg_new:nnn { l3doc } { multiple-syntax }
  {
    The~'syntax'~environment~should~only~be~used~once~in~
    a~'function'~environment.
  }
\msg_new:nnn { l3doc } { deprecated-option }
  { The~option~'#1'~has~been~deprecated~for~'#2'. }
\msg_new:nnn { l3doc } { foreign-internal }
  {
    A~control~sequence~of~the~form~'...__#1'~was~used.~
    It~should~only~be~used~in~the~module~'#2'
    \tl_if_empty:nF {#3} { ,~not~in~'#3' } .
  }
%    \end{macrocode}
%
% \subsection{选项和配置}
%
%    \begin{macrocode}
\DeclareKeys [ l3doc / options ]
  {
    a5paper .code:n = \@latexerr { Option~not~supported } { } ,
    full .code:n =
      {
        \bool_gset_true:N \g_@@_typeset_documentation_bool
        \bool_gset_true:N \g_@@_typeset_implementation_bool
      } ,
   onlydoc .code:n = 
    {
      \bool_gset_true:N \g_@@_typeset_documentation_bool
      \bool_gset_false:N \g_@@_typeset_implementation_bool
    } ,
    check .bool_gset:N = \g_@@_checkfunc_bool ,
    checktest .bool_gset:N = \g_@@_checktest_bool ,
    kernel .bool_gset:N = \g_@@_kernel_bool ,
    stdmodule .bool_gset_inverse:N = \g_@@_kernel_bool ,
    lm-default .bool_gset:N = \g_@@_lmodern_bool ,
    cs-break .bool_gset_inverse:N = \g_@@_cs_break_bool ,
    cs-break-nohyphen .code:n = \PassOptionsToPackage{nohyphen}{underscore} ,
    show-notes .bool_gset:N = \g_@@_show_notes_bool,
    hide-notes .bool_gset_inverse:N = \g_@@_show_notes_bool
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareUnknownKeyHandler [ l3doc / options ]
  { \PassOptionsToClass { \CurrentOption } { article } }
\SetKeys [ l3doc / options ]
  { full , kernel , check = false , checktest = false , lm-default }
\PassOptionsToClass { a4paper } { article }
%    \end{macrocode}
%
% 如果存在本地配置文件，则输入该文件，并向控制台输出已发生此操作的消息。
% 因为我们与类一起分发了一个 \file{.cfg} 文件，所以通常情况下这应该是真的。
% 因此，检查 \cs{ExplMakeTitle}（在我们的 \file{.cfg} 文件中定义），
% 只有当找不到它时才输出信息性消息。
%
%    \begin{macrocode}
\msg_new:nnn { l3doc } { input-cfg }
  { Local~config~file~l3doc.cfg~loaded. }
\file_if_exist:nT { l3doc.cfg }
  {
    \file_input:n { l3doc.cfg }
    \cs_if_exist:cF { ExplMakeTitle }
      { \msg_info:nn { l3doc } { input-cfg } }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\ProcessKeyOptions [ l3doc / options ]
%    \end{macrocode}
%
%
% \subsection{类文件与宏包加载}
%
%    \begin{macrocode}
\LoadClass{article}
\RequirePackage{doc}
\RequirePackage
  {
    array,
    alphalph,
    amsmath,
    amssymb,
    booktabs,
    color,
    colortbl,
    hologo,
    enumitem,
    pifont,
    textcomp,
    trace,
    csquotes,
    fancyvrb,
    underscore,
    verbatim
  }
\raggedbottom
%    \end{macrocode}
%
% 根据选项加载 \pkg{lmodern} 包设置字体。然后将斜的打字机字体替换为
% 斜的字形；前者让我感到不适。（Will, Aug 2011）
%    \begin{macrocode}
\bool_if:NT \g_@@_lmodern_bool
  {
    \RequirePackage[T1]{fontenc}
    \RequirePackage{lmodern}
    \group_begin:
      \ttfamily
      \DeclareFontShape{T1}{lmtt}{m}{it}{<->ec-lmtto10}{}
    \group_end:
  }
%    \end{macrocode}
%
% 必须放在最后，像往常一样。
%    \begin{macrocode}
\RequirePackage{hypdoc}
%    \end{macrocode}
%
% \subsection{配置和调整}
%
% \begin{macro}{\MakePrivateLetters}
%   在 \LaTeX3 编程环境中，还有一些字母是“私有的”。
%    \begin{macrocode}
\cs_gset:Npn \MakePrivateLetters
  {
    \char_set_catcode_letter:N \@
    \char_set_catcode_letter:N \_
    \char_set_catcode_letter:N \:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{CodelineNo}
%   与行编号有关的一些配置。
%    \begin{macrocode}
\setcounter{StandardModuleDepth}{1}
\@addtoreset{CodelineNo}{part}
\tl_replace_once:Nnn \theCodelineNo
  { \HDorg@theCodelineNo }
  { \textcolor[gray]{0.5} { \sffamily\tiny\arabic{CodelineNo} } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\verbatim, \endverbatim}
%   在 \file{.dtx} 文档中，\env{verbatim} 环境会因为只删除第一个“\%”符号，
%   而不是缩进（通常是一个空格），导致额外的空间。用 \pkg{fancyvrb} 修复它：
%    \begin{macrocode}
\fvset{gobble=2}
\cs_gset_eq:NN \verbatim \Verbatim
\cs_gset_eq:NN \endverbatim \endVerbatim
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ifnot@excluded}
%   此函数测试存储在 \tn{macro@namepart} 中的宏名称是否被 \tn{DoNotIndex} 排除
%   了索引。与其尝试修复传入的类别码，不如将所有内容转换为字符串类别码。
%   这略微低效，因为我们本可以确保 \tn{index@excludelist} 一开始就是字符串类别码。
%    \begin{macrocode}
\cs_set_protected:Npn \ifnot@excluded
  {
    \exp_args:Nee \expanded@notin
      { \c_backslash_str \tl_to_str:N \macro@namepart , }
      { \exp_args:NV \tl_to_str:n \index@excludelist }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\pdfstringnewline}
% \begin{macro}{\@@_pdfstring_newline:w}
%   通过使书签中的 |\\|（几乎）变得微不足道，我们避免了一些 hyperref 警告。
%   更确切地说，它可能与星号和可选参数一起使用，因此我们使用 \pkg{ltcmd}
%   可扩展命令将其删除。由于不能有尾随的可选参数，所以捡起额外的必选参数并将其放回。
%    \begin{macrocode}
\cs_new:Npn \pdfstringnewline { : ~ }
\DeclareExpandableDocumentCommand
  { \@@_pdfstring_newline:w } { s o m } { \pdfstringnewline #3 }
\pdfstringdefDisableCommands
  { \cs_set_eq:NN \\ \@@_pdfstring_newline:w }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{设计}
%
% 稍微增加文本宽度，以便在 \env{macrocode} 环境中显示 72 列标准字体的代码。
% 稍微增加边注宽度，以适应较长的命令名称。同时，将左边距增加相同的量。
%    \begin{macrocode}
\setlength   \textwidth      { 385pt }
\addtolength \marginparwidth {  30pt }
\addtolength \oddsidemargin  {  20pt }
\addtolength \evensidemargin {  20pt }
%    \end{macrocode}
% （这些设置是在使用 \cls{article} 文档类时引入的，但我暂时保留它们，
% 以便提醒自己稍后处理。）
%
% \begin{macro}{\list}
% \begin{macro}{\@@_oldlist:nn}
%   自定义列表。
%    \begin{macrocode}
\cs_new_eq:NN \@@_oldlist:nn \list
\cs_gset:Npn \list #1 #2
  { \@@_oldlist:nn {#1} { #2 \dim_zero:N \listparindent } }
\setlength \parindent  { 2em }
\setlength \itemindent { 0pt }
\setlength \parskip    { 0pt plus 3pt minus 0pt }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\partname}
%   在部 (Part) 标题中使用“File”作为名称。
%    \begin{macrocode}
\tl_gset:Nn \partname {File}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l@section, \l@subsection}
%   自定义目录（因为有许多章节，需要不同的设计和/或结构）。
%    \begin{macrocode}
\@addtoreset{section}{part}
\cs_gset:Npn \l@section #1#2
  {
    \ifnum \c@tocdepth >\z@
      \addpenalty\@secpenalty
      \addvspace{1.0em \@plus\p@}
      \setlength\@tempdima{2.5em}  % was 1.5em
      \begingroup
        \parindent \z@ \rightskip \@pnumwidth
        \parfillskip -\@pnumwidth
        \leavevmode \bfseries
        \advance\leftskip\@tempdima
        \hskip -\leftskip
        #1\nobreak\hfil \nobreak\hb@xt@\@pnumwidth{\hss #2}\par
      \endgroup
    \fi
  }
\cs_gset:Npn \l@subsection
  { \@dottedtocline{2}{2.5em}{2.3em} }  % #2 = 1.5em
%    \end{macrocode}
% \end{macro}
%
% \subsection{文本标记}
%
% 使 "|" 和 |"| 成为“短引用”字符，但不在文档导言部分使用，
% 因为活动字符可能会干扰加载的包。在读取 \file{.aux} 文件之前，
% 在文档末尾删除这些短引用，因为它们可能出现在标签中
% （例如，\pkg{l3fp} 中有一个“||”的操作）。
%    \begin{macrocode}
\AtBeginDocument
  {
    \MakeShortVerb \"
    \MakeShortVerb \|
  }
\AtEndDocument
  {
    \DeleteShortVerb \"
    \DeleteShortVerb \|
  }
%    \end{macrocode}
%
% \begin{macro}{\eTeX, \IniTeX, \Lua, \LuaTeX, \pdfTeX, \XeTeX,
%   \pTeX, \upTeX, \epTeX, \eupTeX}
%   一些 logo 的命令。
%    \begin{macrocode}
\providecommand*\eTeX{\hologo{eTeX}}
\providecommand*\IniTeX{\hologo{iniTeX}}
\providecommand*\Lua{Lua}
\providecommand*\LuaTeX{\hologo{LuaTeX}}
\providecommand*\pdfTeX{\hologo{pdfTeX}}
\providecommand*\XeTeX{\hologo{XeTeX}}
\providecommand*\pTeX{p\kern-.2em\hologo{TeX}}
\providecommand*\upTeX{up\kern-.2em\hologo{TeX}}
\providecommand*\epTeX{$\varepsilon$-\pTeX}
\providecommand*\eupTeX{$\varepsilon$-\upTeX}
\providecommand*\ConTeXt{\hologo{ConTeXt}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cmd, \cs, \tn}
%   它们依赖于一个共同的辅助命令 \cs{@@_cmd:nn}，接收选项和一些以反斜杠开头的
%   标记的字符串表示（以支持诸如 |\cs{pkg_\ldots}| 这样的情况，我们不将整个参数转换为字符串）。
%    \begin{macrocode}
\DeclareDocumentCommand \cmd { O{} m }
  { \@@_cmd:no {#1} { \token_to_str:N #2 } }
\DeclareDocumentCommand \cs  { O{} m }
  { \@@_cmd:no {#1} { \c_backslash_str #2 } }
\DeclareDocumentCommand \tn  { O{} m }
  {
    \@@_cmd:no
      { module = TeX , replace = false , #1 }
      { \c_backslash_str #2 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\meta}
%   一个文档级别的命令。
%    \begin{macrocode}
\DeclareDocumentCommand \meta { m }
  { \@@_meta:n {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_pdfstring_cmd:w,
%     \@@_pdfstring_cs:w,
%     \@@_pdfstring_meta:w
%   }
%   为了在书签中工作，这些命令必须是可展开的。
%    \begin{macrocode}
\DeclareExpandableDocumentCommand
  { \@@_pdfstring_cmd:w } { o m } { \token_to_str:N #2 }
\DeclareExpandableDocumentCommand
  { \@@_pdfstring_cs:w }  { o m } { \textbackslash \tl_to_str:n {#2} }
\cs_new:Npn \@@_pdfstring_meta:w #1
  { < \tl_to_str:n {#1} > }
\pdfstringdefDisableCommands
  {
    \cs_set_eq:NN \cmd  \@@_pdfstring_cmd:w
    \cs_set_eq:NN \cs   \@@_pdfstring_cs:w
    \cs_set_eq:NN \tn   \@@_pdfstring_cs:w
    \cs_set_eq:NN \meta \@@_pdfstring_meta:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Arg, \marg, \oarg, \parg}
%   |\marg{text}| 输出 \marg{text}, \enquote{必选参数}.\\
%   |\oarg{text}| 输出 \oarg{text}, \enquote{可选参数}.\\
%   |\parg{te,xt}| 输出 \parg{te,xt}, \enquote{图形模式参数}.
%   最后，\cs{Arg} 与 \cs{marg} 相同。
%    \begin{macrocode}
\newcommand\Arg[1]
  { \texttt{\char`\{} \meta{#1} \texttt{\char`\}} }
\providecommand\marg[1]{ \Arg{#1} }
\providecommand\oarg[1]{ \texttt[ \meta{#1} \texttt] }
\providecommand\parg[1]{ \texttt( \meta{#1} \texttt) }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\file, \env, \pkg, \cls}
%   这个列表可能会改变……这只是我对标记的偏好。
%    \begin{macrocode}
\DeclareRobustCommand \file {\nolinkurl}
\DeclareRobustCommand \env {\texttt}
\DeclareRobustCommand \pkg {\textsf}
\DeclareRobustCommand \cls {\textsf}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\EnableDocumentation, \EnableImplementation}
% \begin{macro}{\DisableDocumentation, \DisableImplementation}
%   控制是否排版文档/实现。这些只是设定了两个开关。
%    \begin{macrocode}
\NewDocumentCommand \EnableDocumentation { }
  { \bool_gset_true:N \g_@@_typeset_documentation_bool }
\NewDocumentCommand \EnableImplementation { }
  { \bool_gset_true:N \g_@@_typeset_implementation_bool }
\NewDocumentCommand \DisableDocumentation { }
  { \bool_gset_false:N \g_@@_typeset_documentation_bool }
\NewDocumentCommand \DisableImplementation { }
  { \bool_gset_false:N \g_@@_typeset_implementation_bool }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{environment}{documentation}
% \begin{environment}{implementation}
%   如果需要排版文档/实现，只需设置布尔值 \cs{l_@@_in_implementation_bool}，指示是否在实现部分。否则使用 \cs{comment}（和配对的 \cs{endcomment}）。
%    \begin{macrocode}
\NewDocumentEnvironment { documentation } { }
  {
    \bool_if:NTF \g_@@_typeset_documentation_bool
      { \bool_set_false:N \l_@@_in_implementation_bool }
      { \comment }
  }
  { \bool_if:NF \g_@@_typeset_documentation_bool { \endcomment } }
\NewDocumentEnvironment { implementation } { }
  {
    \bool_if:NTF \g_@@_typeset_implementation_bool
      { \bool_set_true:N \l_@@_in_implementation_bool }
      { \comment }
  }
  { \bool_if:NF \g_@@_typeset_implementation_bool { \endcomment } }
%    \end{macrocode}
% \end{environment}
% \end{environment}
%
% \begin{environment}{variable}
%   \env{variable} 环境根据文档部分的不同行为类似于 \env{function} 或 \env{macro} 环境。
%    \begin{macrocode}
\DeclareDocumentEnvironment { variable } { O{} +v }
  {
    \bool_if:NTF \l_@@_in_implementation_bool
      { \@@_macro:nnw { var , #1 } {#2} }
      { \@@_function:nnw {#1} {#2} }
  }
  {
    \bool_if:NTF \l_@@_in_implementation_bool
      { \@@_macro_end: }
      { \@@_function_end: }
  }
%    \end{macrocode}
% \end{environment}
%
% \begin{environment}{function}
% \begin{environment}{macro}
%   用于记录函数的环境，以及用于记录宏实现的环境。
%    \begin{macrocode}
\DeclareDocumentEnvironment { function } { O{} +v }
  { \@@_function:nnw {#1} {#2} }
  { \@@_function_end: }
\DeclareDocumentEnvironment { macro } { O{} +v }
  { \@@_macro:nnw {#1} {#2} }
  { \@@_macro_end: }
%    \end{macrocode}
% \end{environment}
% \end{environment}
%
% \begin{environment}{syntax}
%   语法块放置在函数列表旁边，用于说明它们的用法。TODO：测试 \env{syntax} 环境是否仅在 \env{function} 环境内使用，且仅出现一次。
%    \begin{macrocode}
\NewDocumentEnvironment { syntax } { }
  { \@@_syntax:w }
  {
    \@@_syntax_end:
    \ignorespacesafterend
  }
%    \end{macrocode}
% \end{environment}
%
% \begin{environment}{texnote}
%   用于描述仅供 \TeX{} 专家阅读的信息。
%    \begin{macrocode}
\NewDocumentEnvironment { texnote } { }
  {
    \endgraf
    \vspace{3mm}
    \small\textbf{\TeX~hackers~note:}
  }
  {
    \vspace{3mm}
  }
%    \end{macrocode}
% \end{environment}
%
% \begin{environment}{arguments}
%   此环境设计用于在 \env{macro} 环境中描述宏/函数的参数。
%    \begin{macrocode}
\NewDocumentEnvironment { arguments } { }
  {
    \enumerate [
      nolistsep ,
      label = \texttt{\#\arabic*} ~ : ,
      labelsep = * ,
    ]
  }
  {
    \endenumerate
  }
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\CodedocExplain, \CodedocExplainEXP, \CodedocExplainREXP, \CodedocExplainTF}
%   解释星号和 |TF| 符号的用法，供第三方包使用。
%    \begin{macrocode}
\NewDocumentCommand { \CodedocExplain } { }
  { \CodedocExplainEXP \ \CodedocExplainREXP \ \CodedocExplainTF }
\NewDocumentCommand { \CodedocExplainEXP } { }
  {
    \raisebox{\baselineskip}[0pt][0pt]{\hypertarget{expstar}{}}%
    \write \@auxout { \def \string \Codedoc@expstar { } }
    \@@_typeset_exp:\ indicates~fully~expandable~functions,~which~
    can~be~used~within~an~\texttt{e}-type~argument~(inside~an~\tn{expanded}),~
    \texttt{x}-type~argument~(in~plain~\TeX{}~terms,~inside~an~\tn{edef}),~
    as~well~as~within~an~\texttt{f}-type~argument.
  }
\NewDocumentCommand { \CodedocExplainREXP } { }
  {
    \raisebox{\baselineskip}[0pt][0pt]{\hypertarget{rexpstar}{}}%
    \write \@auxout { \def \string \Codedoc@rexpstar { } }
    \@@_typeset_rexp:\ indicates~
    restricted~expandable~functions,~which~can~be~used~within~an~
    \texttt{x}-type~argument~or~an~\texttt{e}-type~argument,~
    but~cannot~be~fully~expanded~within~an~\texttt{f}-type~argument.
  }
\NewDocumentCommand { \CodedocExplainTF } { }
  {
    \raisebox{\baselineskip}[0pt][0pt]{\hypertarget{explTF}{}}%
    \write \@auxout { \def \string \Codedoc@explTF { } }
    \@@_typeset_TF:\ indicates~conditional~(\texttt{if})~functions~
    whose~variants~with~\texttt{T},~\texttt{F}~and~\texttt{TF}~
    argument~specifiers~expect~different~
    \enquote{true}/\enquote{false}~branches.
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{实现文本标记}
%
% \cs{cmd}、\cs{cs}和\cs{tn}的键。
%    \begin{macrocode}
\keys_define:nn { l3doc/cmd }
  {
    index     .tl_set:N     = \l_@@_cmd_index_tl        ,
    module    .tl_set:N     = \l_@@_cmd_module_tl       ,
    no-index  .bool_set:N   = \l_@@_cmd_noindex_bool    ,
    replace   .bool_set:N   = \l_@@_cmd_replace_bool    ,
  }
%    \end{macrocode}
%
% \begin{macro}[do-not-index={\\,\_,\1,\c,\2}]{\@@_cmd:nn, \@@_cmd:no}
%   在设置一些默认值后应用键-值 \meta{options}~|#1|。然后（除非 |replace=false|）
%   替换 |@@| 中的~|#2|，这有点棘手：|_| 必须给出 \cs{@@_replace_at_at:N} 期望
%   的类别码，但应该在不重新扫描整个参数的情况下恢复到其原始的类别码（通常是活动的，
%   需要进行换行）。然后，在将其转换为无害字符后（保持下划线可断行），将命令设置为 
%   \tn{verbatim@font} 中进行排版；在任何情况下，空格必须转换为 \tn{@xobeysp}，
%   我们必须使用 \tn{@} 来避免在控制序列之后产生更长的空格，例如以冒号结尾的控制
%   序列（空签名）。最后，生成索引条目。当 \cs{l_@@_cmd_noindex_bool} 为 true 
%   时，索引被抑制。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cmd:nn #1#2
  {
    \bool_set_false:N \l_@@_cmd_noindex_bool
    \bool_set_true:N \l_@@_cmd_replace_bool
    \tl_set:Nn \l_@@_cmd_index_tl { \q_no_value }
    \tl_set:Nn \l_@@_cmd_module_tl { \q_no_value }
    \keys_set:nn { l3doc/cmd } {#1}
    \tl_set:Nn \l_@@_cmd_tl {#2}
    \bool_if:NT \l_@@_cmd_replace_bool
      {
        \tl_set_rescan:Nnn \l_@@_tmpb_tl { } { _ }
        \tl_replace_all:NVn \l_@@_cmd_tl \l_@@_tmpb_tl { _ }
        \@@_replace_at_at:N \l_@@_cmd_tl
        \tl_replace_all:NnV \l_@@_cmd_tl { _ } \l_@@_tmpb_tl
      }
%    \end{macrocode}
% 排版。
% 注意下划线的替换是为了允许换行。
% \texttt{underscore} 宏包添加了换行，
% 正则表达式导致仅将可断行的下划线应用于下划线的 \emph{最后一个}，而不是下划线跟在反斜杠后面的情况。
%    \begin{macrocode}
    \mode_if_math:T { \mbox }
      {
        \bool_if:NT \l_@@_allow_indexing_bool { \@@_target: }
        \verbatim@font
        \@@_if_almost_str:VT \l_@@_cmd_tl
          {
            \__kernel_tl_set:Ne \l_@@_cmd_tl { \tl_to_str:N \l_@@_cmd_tl }
            \bool_if:NT \g_@@_cs_break_bool
              {
                \regex_replace_all:nnN
                  { ([^\\\_]\_*) \_ ([^\_]) }
                  { \1 \c{BreakableUnderscore} \2 }
                  \l_@@_cmd_tl
              }
          }
        \tl_replace_all:Nnn \l_@@_cmd_tl { ~ } { \@xobeysp }
        \l_@@_cmd_tl
        \@
      }
%    \end{macrocode}
% 索引。
%    \begin{macrocode}
    \bool_if:NT \l_@@_allow_indexing_bool
     {
      \bool_if:NF \l_@@_cmd_noindex_bool
       {
        \quark_if_no_value:NF \l_@@_cmd_index_tl
          {
            \__kernel_tl_set:Ne \l_@@_cmd_tl
              { \c_backslash_str \exp_not:o { \l_@@_cmd_index_tl } }
          }
        \exp_args:No \@@_key_get:n { \l_@@_cmd_tl }
        \quark_if_no_value:NF \l_@@_cmd_module_tl
          {
            \__kernel_tl_set:Ne \l_@@_index_module_tl
              { \tl_to_str:N \l_@@_cmd_module_tl }
          }
        \@@_special_index_module:ooonN
          { \l_@@_index_key_tl }
          { \l_@@_index_macro_tl }
          { \l_@@_index_module_tl }
          { usage }
          \l_@@_index_internal_bool
       }
     }
  }
\cs_generate_variant:Nn \@@_cmd:nn { no }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_meta:n,
%     \@@_ensuremath_sb:n,
%     \@@_meta_original:n
%   }
% 将 |#1| 存储在 \cs{l_@@_tmpa_tl} 中，并替换每个下划线，无论其类别是什么
% （\enquote{math toggle}、\enquote{alignment}、\enquote{superscript}、
% \enquote{subscript}、\enquote{letter}、\enquote{other} 或 
% \enquote{active}），都用 \cs{@@_ensuremath_sb:n} 替换（这会创建数学下
% 标），然后运行 \pkg{doc.sty} 中用于 \tn{meta} 的代码。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_meta:n #1
  {
    \tl_set:Nn \l_@@_tmpa_tl {#1}
    \tl_map_inline:nn
      { { 3 } { 4 } { 7 } { 8 } { 11 } { 12 } { 13 } }
      {
        \tl_set_rescan:Nnn \l_@@_tmpb_tl
          { \char_set_catcode:nn { `_ } {##1} } { _ }
        \tl_replace_all:NVn \l_@@_tmpa_tl \l_@@_tmpb_tl
          { \@@_ensuremath_sb:n }
      }
    \exp_args:NV \@@_meta_original:n \l_@@_tmpa_tl
  }
\cs_new_protected:Npn \@@_ensuremath_sb:n #1
  { \ensuremath { \sb {#1} } }
\cs_new_protected:Npn \@@_meta_original:n #1
  {
    \ensuremath \langle
    \mode_if_math:T { \nfss@text }
    {
      \meta@font@select
      \edef \meta@hyphen@restore
        { \hyphenchar \the \font \the \hyphenchar \font }
      \hyphenchar \font \m@ne
      \language \l@nohyphenation
      #1 \/
      \meta@hyphen@restore
    }
    \ensuremath \rangle
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{\env{macro} 和 \env{function} 之间共通的部分}
%
% \begin{macro}
%   {
%     \@@_typeset_exp:, \@@_typeset_rexp:,
%     \@@_typeset_TF:, \@@_typeset_aux:n
%   }
%   被 \cs{@@_macro_single:nNN} 使用，也在 \env{function} 环境中用于排版条件语句和辅助函数。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_typeset_exp:
  {
    \cs_if_exist:NTF \Codedoc@expstar
      { \hyperlink { expstar } }
      { \mbox }
    {$\star$}
  }
\cs_new_protected:Npn \@@_typeset_rexp:
  {
    \cs_if_exist:NTF \Codedoc@rexpstar
      { \hyperlink { rexpstar } }
      { \mbox }
    { \ding { 73 } } % hollow star
  }
\cs_new_protected:Npn \@@_typeset_TF:
  {
    \cs_if_exist:NTF \Codedoc@explTF
      { \hyperlink { explTF } }
      { \mbox }
      {
        \color{black}
        \itshape TF
        \makebox[0pt][r]
          {
            \cs_if_exist:NT \Codedoc@explTF { \color{red} }
            \underline { \phantom{\itshape TF} \kern-0.1em }
          }
      }
  }
\cs_new_protected:Npn \@@_typeset_aux:n #1
  {
    { \color[gray]{0.5} #1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {\@@_get_hyper_target:nN, \@@_get_hyper_target:oN, \@@_get_hyper_target:eN}
% 从宏名称 |#1| 创建一个 \pkg{hyperref} 锚点，并将其存储在记号列表变量 |#2| 
% 中。例如，|\prg_replicate:nn| 变成 |doc/function//prg/replicate:nn|。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_get_hyper_target:nN #1#2
  {
    \__kernel_tl_set:Ne #2 { \tl_to_str:n {#1} }
    \tl_replace_all:NVn #2 \c_underscore_str { / }
    \tl_remove_all:NV   #2 \c_backslash_str
    \tl_put_left:Nn #2 { doc/function// }
  }
\cs_generate_variant:Nn \@@_get_hyper_target:nN { o , e }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_names_get_seq:nN}
% 参数 |#1|（在 |function| 或 |macro| 环境的参数）的类别码为 $10$（空格），
% $12$（其他）和 $13$（活动）。对类别码进行清理。如果使用了 |verb| 选项，则
% 输出一个单项序列。否则，移除位于行首的任何 \enquote{\%} 字符。移除制表符和
% 换行符。最后，将 |_@@| 和 |@@| 转换为 |__|\meta{module name}（如果非空）。
% 此时，\cs{l_@@_tmpa_tl} 包含一个逗号分隔的名称列表，其中 |@| 和~|_| 的类
% 别码为字母。将其转换为字符串，解析为逗号分隔的列表（特别是移除了空格），并
% 输出一系列函数/宏名称。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_names_get_seq:nN #1#2
  {
    \__kernel_tl_set:Ne \l_@@_tmpa_tl { \tl_to_str:n {#1} }
    \bool_if:NTF \l_@@_names_verb_bool
      {
        \seq_clear:N #2
        \seq_put_right:NV #2 \l_@@_tmpa_tl
      }
      {
        \tl_remove_all:Ne \l_@@_tmpa_tl
          { \iow_char:N \^^M \c_percent_str }
        \tl_remove_all:Ne \l_@@_tmpa_tl { \tl_to_str:n { ^ ^ A } }
        \tl_remove_all:Ne \l_@@_tmpa_tl { \iow_char:N \^^I }
        \tl_remove_all:Ne \l_@@_tmpa_tl { \iow_char:N \^^M }
        \@@_detect_internals:N \l_@@_tmpa_tl
        \@@_replace_at_at:N \l_@@_tmpa_tl
        \exp_args:NNe \seq_set_from_clist:Nn #2
          { \tl_to_str:N \l_@@_tmpa_tl }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_names_parse:, \@@_names_parse_one:n}
% 目标是将变体组合在一起。我们使用 \cs{@@_lseq_name:n} 在基本形式后创建局部
% 序列变量，并将其填充到 \cs{l_@@_names_block_tl} 中。当遇到新的基本形式时，
% 设置相应的局部序列来保存 \meta{base name}（去除签名），并将局部序列添加到
% 列表 \cs{l_@@_names_block_tl} 中。在所有情况下，将签名附加到局部序列中，
% 因此它采用了这样的形式：\meta{base name}、\meta{signature_1}、
% \meta{signature_2} 等等。如果原始函数没有签名（没有冒号），则使用 
% \cs{scan_stop:} 作为签名（没有变体）。我们特别处理以 |\::| 开头的命令 |#1|，
% 即命名为 |\::N| 等的奇怪函数。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_names_parse:
  {
    \tl_clear:N \l_@@_names_block_tl
    \seq_map_function:NN
      \l_@@_names_seq
      \@@_names_parse_one:n
  }
\cs_new_protected:Npn \@@_names_parse_one:n #1
  {
    \@@_split_function_do:nn {#1}
      { \@@_names_parse_one_aux:nnNn }
    {#1}
  }
\cs_new_protected:Npn \@@_names_parse_one_aux:nnNn #1#2#3#4
  {
    \bool_if:NTF #3
      {
        \tl_if_head_eq_charcode:nNTF {#2} :
          { \@@_names_parse_aux:nnn {#4} {#4} { \scan_stop: } }
          {
            \exp_args:Ne \@@_names_parse_aux:nnn
              { \@@_base_form_aux:nnN {#1} {#2} #3 }
              {#1} {#2}
          }
      }
      {
        \bool_if:NT \l_@@_macro_TF_bool
          { \msg_error:nne { l3doc } { no-signature-TF } {#4} }
        \@@_names_parse_aux:nnn {#4} {#4} { \scan_stop: }
      }
  }
\cs_new_protected:Npn \@@_names_parse_aux:nnn #1
  { \exp_args:Nc \@@_names_parse_aux:Nnn { \@@_lseq_name:n {#1} } }
\cs_new_protected:Npn \@@_names_parse_aux:Nnn #1#2#3
  {
    \tl_if_in:NnF \l_@@_names_block_tl {#1}
      {
        \tl_put_right:Nn \l_@@_names_block_tl {#1}
        \seq_clear_new:N #1
        \seq_put_right:Nn #1 {#2}
      }
    \seq_put_right:Nn #1 {#3}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_names_typeset:}
% \begin{macro}{\@@_names_typeset_auxi:n}
%   此代码特别用于在 \env{function} 环境中排版函数名称时。对于 
%   \cs{l_@@_names_block_tl} 的映射不能使用 \cs{tl_map_inline:Nn}，因为跟在 
%   |\\| 之后的代码将不可展开，因此会破坏 \tn{bottomrule}。
%
%   对每个局部序列（其中包含一组变体）调用 \cs{@@_names_typeset_auxi:n}。第
%   一步是弹出基本形式，并将空格更改为其他类别码，以便最终显示出来。然后将变体
%   存储在 \cs{g_@@_variants_seq} 中，移除第一个（它将更显眼地显示），并重建
%   实际名称，将其传递给 \cs{@@_names_typeset_auxii:n}。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_names_typeset:
  {
    \tl_map_function:NN \l_@@_names_block_tl
      \@@_names_typeset_auxi:n
  }
\cs_new_protected:Npn \@@_names_typeset_auxi:n #1
  {
    \seq_pop:NN #1 \l_@@_tmpa_tl
    \tl_gset_eq:NN \g_@@_base_name_tl \l_@@_tmpa_tl
    \tl_greplace_all:NnV \g_@@_base_name_tl
      { ~ } \c_catcode_other_space_tl
    \seq_get:NN #1 \l_@@_tmpa_tl
    \str_if_eq:VnTF \l_@@_tmpa_tl { \scan_stop: }
      {
        \seq_gclear:N \g_@@_variants_seq
        \@@_names_typeset_auxii:e { \g_@@_base_name_tl }
      }
      {
        \seq_gset_eq:NN \g_@@_variants_seq #1
        \seq_gpop:NN \g_@@_variants_seq \l_@@_tmpb_tl
        \@@_names_typeset_auxii:e
          { \g_@@_base_name_tl : \l_@@_tmpb_tl }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {\@@_names_typeset_auxii:n, \@@_names_typeset_auxii:e}
%   如果给定选项 |pTF|，在 |TF| 函数之前排版谓词。
%   如果给定选项 |noTF|，也排版非 |TF| 函数。
%   在这两种情况下都传递相关的布尔值，控制是否追加 |TF|。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_names_typeset_auxii:n #1
  {
    \bool_if:NT \l_@@_macro_pTF_bool
      {
        \@@_names_typeset_block:eN
          { \@@_predicate_from_base:n {#1} }
          \c_false_bool
      }
    \bool_if:NT \l_@@_macro_noTF_bool
      { \@@_names_typeset_block:nN {#1} \c_false_bool }
    \@@_names_typeset_block:nN {#1} \l_@@_macro_TF_bool
  }
\cs_generate_variant:Nn \@@_names_typeset_auxii:n { e }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_names_typeset_block:nN, \@@_names_typeset_block:eN}
%   \env{function} 和 \env{macro} 环境中的名称排版方式不同。
%   要区分这两者，请注意当处于 \env{macro} 环境时 \cs{l_@@_nested_macro_int} 至少为1
%   （我们假设 \env{function} 不会嵌套在其中）。
%   一个块是包含其所有变体的函数。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_names_typeset_block:nN
  {
    \int_compare:nNnTF \l_@@_nested_macro_int = 0
      { \@@_typeset_function_block:nN }
      { \@@_macro_typeset_block:nN }
  }
\cs_generate_variant:Nn \@@_names_typeset_block:nN { e }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\@@_if_macro_internal:n}
% \begin{macro}[EXP]{\@@_if_macro_internal_aux:w}
%   确定给定的宏应视为内部还是公共。
%   如果给出诸如 |int| 的选项，则答案是 \cs{l_@@_macro_internal_bool}，
%   否则检查宏名称是否包含 |__|。
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_macro_internal:n #1 { p , T , F , TF }
  {
    \bool_if:NTF \l_@@_macro_internal_bool
      { \prg_return_true: }
      {
        \tl_if_empty:eTF
          {
            \exp_after:wN \@@_if_macro_internal_aux:w
            \tl_to_str:n { #1 ~ __ }
          }
          { \prg_return_false: } { \prg_return_true: }
      }
  }
\exp_last_unbraced:NNNNo
  \cs_new:Npn \@@_if_macro_internal_aux:w #1 { \tl_to_str:n { __ } } { }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_names_block_base_map:N}
%   \cs{l_@@_names_block_tl} 包含与不同基本函数及其变体对应的序列变量。
%   对于每个这样的序列，将第一个和第二个项目放入 \cs{l_@@_tmpa_tl} 和 \cs{l_@@_tmpb_tl} 中，
%   并构建基本函数的名称。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_names_block_base_map:N #1
  {
    \tl_map_inline:Nn \l_@@_names_block_tl
      {
        \group_begin:
          \seq_set_eq:NN \l_@@_tmpa_seq ##1
          \seq_pop:NN \l_@@_tmpa_seq \l_@@_tmpa_tl
          \seq_get:NN \l_@@_tmpa_seq \l_@@_tmpb_tl
          \exp_args:NNe
        \group_end:
        #1
          {
            \l_@@_tmpa_tl
            \str_if_eq:VnF \l_@@_tmpb_tl { \scan_stop: }
              { : \l_@@_tmpb_tl }
            \bool_if:NT \l_@@_macro_TF_bool { TF }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{\env{function} 环境}
%
%    \begin{macrocode}
\keys_define:nn { l3doc/function }
  {
    TF .value_forbidden:n = true ,
    TF .code:n =
      {
        \bool_set_true:N \l_@@_macro_TF_bool
      } ,
    EXP .value_forbidden:n = true ,
    EXP .code:n =
      {
        \bool_set_true:N \l_@@_macro_EXP_bool
        \bool_set_false:N \l_@@_macro_rEXP_bool
      } ,
    rEXP .value_forbidden:n = true ,
    rEXP .code:n =
      {
        \bool_set_false:N \l_@@_macro_EXP_bool
        \bool_set_true:N \l_@@_macro_rEXP_bool
      } ,
    pTF .value_forbidden:n = true ,
    pTF .code:n =
      {
        \bool_set_true:N \l_@@_macro_pTF_bool
        \bool_set_true:N \l_@@_macro_TF_bool
        \bool_set_true:N \l_@@_macro_EXP_bool
        \bool_set_false:N \l_@@_macro_rEXP_bool
      } ,
    noTF .value_forbidden:n = true ,
    noTF .code:n =
      {
        \bool_set_true:N \l_@@_macro_noTF_bool
        \bool_set_true:N \l_@@_macro_TF_bool
      } ,
    added .code:n = { \@@_date_set_past:Nn \l_@@_date_added_tl {#1} },
    updated .code:n = { \@@_date_set_past:Nn \l_@@_date_updated_tl {#1} } ,
    deprecated .bool_set:N = \l_@@_macro_deprecated_bool , 
    no-user-doc .bool_set:N = \l_@@_macro_nodoc_bool ,
    tested .code:n = { } ,
    label .code:n =
      {
        \clist_set:Nn \l_@@_function_label_clist {#1}
        \bool_set_true:N \l_@@_no_label_bool
      } ,
    verb .value_forbidden:n = true ,
    verb .bool_set:N = \l_@@_names_verb_bool ,
    module .tl_set:N = \l_@@_override_module_tl ,
  }
%    \end{macrocode}
%
% \begin{macro}[do-not-index={\A,\Z,\d,\1,\2,\3}]
%     {\@@_date_set:Nn,\@@_date_set_past:Nn}
%   将日期标准化为格式 \texttt{YYYY-MM-DD}；更精确地说，允许月份和日期为单个数字。
%   函数 \cs{@@_date_set_past:Nn} 仅允许过去（或同一天）的日期。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_date_set:Nn #1#2
  {
    \tl_set:Nn #1 {#2}
    \regex_replace_once:nnNF
      { \A(\d\d\d\d)[-/](\d\d?)[-/](\d\d?)\Z } { \1-\2-\3 } #1
      {
        \msg_error:nnn { l3doc } { date-format } {#2}
        \tl_set:Nn #1 { 1970-01-01 }
      }
  }
\cs_new_protected:Npn \@@_date_set_past:Nn #1#2
  {
    \@@_date_set:Nn #1 {#2}
    \exp_args:No \@@_date_compare:nNnT
      {#1} > { \c_sys_year_int - \c_sys_month_int - \c_sys_day_int }
      {
        \msg_error:nnee { l3doc } { future-date }
          { \tl_to_str:N \l_@@_macro_argument_tl }
          {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_function:nnw}
%   \begin{arguments}
%     \item 键-值列表。
%     \item 逗号分隔的函数列表；输入在读取参数之前已经通过改变类别码进行了清理。
%   \end{arguments}
% \begin{macro}{\@@_function_end:}
%   确保任何段落都已结束，并确保环境开始时类似的安全实践。
%   初始化一些变量。解析键-值列表。清理函数列表，然后遍历其中提取一些数据。
%   在此之后，在存放函数名的装订盒 \cs{l_@@_functions_coffin} 中排版函数名称，并测量其大小以确定是否适合边距。
%   最后，开始一个垂直装订盒用于环境的主要部分。当环境结束时，此装订盒停止，然后所有部分被组装成一个单一的装订盒，并进行排版。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_function:nnw #1#2
  {
    \@@_function_typeset_start:
    \@@_function_init:
    \tl_set:Nn \l_@@_macro_argument_tl {#2}
    \keys_set:nn { l3doc/function } {#1}
    \@@_names_get_seq:nN {#2} \l_@@_names_seq
    \@@_names_parse:
    \@@_function_typeset:
    \@@_function_reset:
    \@@_function_descr_start:w
  }
\cs_new_protected:Npn \@@_function_end:
  {
    \@@_function_descr_stop:
    \@@_function_assemble:
    \@@_function_typeset_stop:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {\@@_function_typeset_start:, \@@_function_typeset_stop:}
%   在 \env{function} 环境开始之前，在执行任何赋值之前，关闭上一个段落，并设置排版场景。
%   进一步的代码排版一个装订盒，因此我们结束段落并允许换页。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_function_typeset_start:
  {
    \par \bigskip \noindent
  }
\cs_new_protected:Npn \@@_function_typeset_stop:
  {
    \par
    \dim_set:Nn \prevdepth { \box_dp:N \l_@@_descr_coffin }
    \allowbreak
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_function_init:}
%   如果嵌套了 \texttt{function} 环境，则发出警告。清除各种变量。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_function_init:
  {
    \box_if_empty:NF \g_@@_syntax_box
      { \msg_error:nn { l3doc } { syntax-nested-function } }
    \coffin_clear:N \l_@@_descr_coffin
    \box_gclear:N \g_@@_syntax_box
    \coffin_clear:N \l_@@_syntax_coffin
    \coffin_clear:N \l_@@_functions_coffin
    \bool_set_false:N \l_@@_macro_TF_bool
    \bool_set_false:N \l_@@_macro_pTF_bool
    \bool_set_false:N \l_@@_macro_noTF_bool
    \bool_set_false:N \l_@@_macro_EXP_bool
    \bool_set_false:N \l_@@_macro_rEXP_bool
    \bool_set_false:N \l_@@_no_label_bool
    \bool_set_false:N \l_@@_names_verb_bool
    \bool_set_true:N \l_@@_in_function_bool
    \clist_clear:N \l_@@_function_label_clist
    \tl_set:Nn \l_@@_override_module_tl { \q_no_value }
    \char_set_active_eq:NN \< \@@_shorthand_meta:
    \char_set_catcode_active:N \<
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_shorthand_meta:, \@@_shorthand_meta:w}
%   允许使用 |<...>| 作为 |\meta{...}| 的标记。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_shorthand_meta:
  { \mode_if_math:TF { < } { \@@_shorthand_meta:w } }
\cs_new_protected_nopar:Npn \@@_shorthand_meta:w #1 > { \meta {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_function_reset:}
%   清除一些变量。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_function_reset:
  {
    \tl_set:Nn \l_@@_override_module_tl { \q_no_value }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_function_typeset:}
%   在装订盒 \cs{l_@@_functions_coffin} 中排版 \cs{l_@@_names_block_tl} 中列出的函数以及相关日期，
%   然后如果此装订盒大于边距中可用的宽度，则将 \cs{l_@@_long_name_bool} 设置为 \texttt{true}。
%   函数 \cs{@@_typeset_functions:} 相当复杂，因此稍后给出。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_function_typeset:
  {
    \dim_zero:N \l_@@_trial_width_dim
    \hcoffin_set:Nn \l_@@_functions_coffin { \@@_typeset_functions: }
    \dim_set:Nn \l_@@_trial_width_dim
      { \box_wd:N \l_@@_functions_coffin }
    \bool_set:Nn \l_@@_long_name_bool
      { \dim_compare_p:nNn \l_@@_trial_width_dim > \marginparwidth }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {\@@_function_descr_start:w, \@@_function_descr_stop:}
%   \cs{@@_function:nnw} 的最后一步（\env{function} 环境的开始）是打开一个装订盒，用于捕获函数的描述，即 \env{function} 环境的正文。
%   这由 \cs{@@_function_end:}（\env{function} 环境的结束）关闭。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_function_descr_start:w
  {
    \vcoffin_set:Nnw \l_@@_descr_coffin { \textwidth }
      \noindent \ignorespaces
  }
\cs_new_protected:Npn \@@_function_descr_stop:
  { \vcoffin_set_end: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_function_assemble:}
%   \cs{g_@@_syntax_box} 包含语法环境的内容（如果使用了）。现在我们有了所有的部分，将语法装订盒、名称装订盒和描述装订盒组合在一起。
%   相对位置取决于名称装订盒是否适合边距。然后排版组合内容。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_function_assemble:
  {
    \hcoffin_set:Nn  \l_@@_syntax_coffin
      { \box_use_drop:N \g_@@_syntax_box }
    \bool_if:NTF \l_@@_long_name_bool
      {
        \coffin_join:NnnNnnnn
          \l_@@_output_coffin {hc} {vc}
          \l_@@_syntax_coffin {l} {T}
          {0pt} {0pt}
        \coffin_join:NnnNnnnn
          \l_@@_output_coffin {l} {t}
          \l_@@_functions_coffin  {r} {t}
          {-\marginparsep} {0pt}
        \coffin_join:NnnNnnnn
          \l_@@_output_coffin {l} {b}
          \l_@@_descr_coffin  {l} {t}
          {0.75\marginparwidth + \marginparsep} {-\medskipamount}
        \coffin_typeset:Nnnnn \l_@@_output_coffin
          {\l_@@_descr_coffin-l} {\l_@@_descr_coffin-t}
          {0pt} {0pt}
      }
      {
        \coffin_join:NnnNnnnn
          \l_@@_output_coffin {hc} {vc}
          \l_@@_syntax_coffin {l} {t}
          {0pt} {0pt}
        \coffin_join:NnnNnnnn
          \l_@@_output_coffin {l} {b}
          \l_@@_descr_coffin  {l} {t}
          {0pt} {-\medskipamount}
        \coffin_join:NnnNnnnn
          \l_@@_output_coffin {l} {t}
          \l_@@_functions_coffin  {r} {t}
          {-\marginparsep} {0pt}
        \coffin_typeset:Nnnnn \l_@@_output_coffin
          {\l_@@_syntax_coffin-l} {\l_@@_syntax_coffin-T}
          {0pt} {0pt}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_typeset_functions:}
%   此函数通过在 \env{tabular} 环境中排版函数名称（带有变体）和相关日期来构建 \cs{l_@@_functions_coffin}。
%   使用 \tn{toprule}、\tn{midrule} 和 \tn{bottomrule} 的规则要求最后一个 |\\| 和规则之间的任何内容都是可展开的，
%   这使得我们的工作变得有些复杂。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_typeset_functions:
  {
    \small\ttfamily
    \@@_target:
    \Hy@MakeCurrentHref { HD. \int_use:N \c@HD@hypercount }
    \begin{tabular} [t] { @{} l @{} >{\hspace{\tabcolsep}} r @{} }
      \toprule
      \@@_function_extra_labels:
      \@@_names_typeset:
      \@@_typeset_dates:
      \bottomrule
    \end{tabular}
    \normalfont\normalsize
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A TODO: collect all index targets from a given function environment in a box and stick it at the top.
% \begin{macro}
%   {\@@_typeset_function_block:nN, \@@_typeset_function_block:eN}
% \begin{macro}{\@@_function_index:n, \@@_function_index:e}
%   |#1| 是一个控制序列名称，|#2| 是一个布尔值，指示是否添加 |TF|。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_typeset_function_block:nN #1#2
  {
    \@@_function_index:e
      { #1 \bool_if:NT #2 { \tl_to_str:n {TF} } }
    \@@_function_label:eN {#1} #2
    #1
    \bool_if:NT #2 { \@@_typeset_TF: }
    \@@_typeset_expandability:
    \seq_if_empty:NF \g_@@_variants_seq
      { \@@_typeset_variant_list:nN {#1} #2 }
    \\
  }
\cs_generate_variant:Nn \@@_typeset_function_block:nN { e }
\cs_new_protected:Npn \@@_function_index:n #1
  {
    \seq_gput_right:Nn \g_doc_functions_seq {#1}
    \@@_special_index:nn {#1} { usage }
  }
\cs_generate_variant:Nn \@@_function_index:n { e }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_typeset_expandability:
  {
    &
    \bool_if:NT \l_@@_macro_EXP_bool  { \@@_typeset_exp: }
    \bool_if:NT \l_@@_macro_rEXP_bool { \@@_typeset_rexp: }
  }
%    \end{macrocode}
%
% |#1| 是函数，|#2| 是否添加 |TF|。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_typeset_variant_list:nN #1#2
  {
    \\
    \@@_typeset_aux:n { \@@_get_function_name:n {#1} }
    :
    \int_compare:nTF { \seq_count:N \g_@@_variants_seq == 1 }
      { \seq_use:Nn \g_@@_variants_seq { } }
      {
        \hbox_set:Nn \l_tmpa_box
          { \seq_use:Nn \g__@@_variants_seq { \textrm| \nolinebreak[2] } }
        \textrm(
%    \end{macrocode}
%
%   设置长变体列表在一个段落盒子中，短列表设置自然长度。
%    \begin{macrocode}
        \dim_compare:nNnTF { \box_wd:N \l_tmpa_box } > { .4\columnwidth }
          {
            \parbox[t]{.4\columnwidth}
              {
                \raggedright
                \hbox_unpack_drop:N \l_tmpa_box
                \textrm)
                \bool_if:NT #2 { \@@_typeset_TF: }
              }
          }
          {
            \hbox_unpack_drop:N \l_tmpa_box
            \textrm)
            \bool_if:NT #2 { \@@_typeset_TF: }
          }
      }
    \@@_typeset_expandability:
  }
%    \end{macrocode}
%
% |#1| 是函数名，|#2| 是否添加 |TF|。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_function_extra_labels:
  {
    \bool_if:NT \l_@@_no_label_bool
      {
        \clist_map_inline:Nn \l_@@_function_label_clist
          {
            \@@_get_hyper_target:oN { \token_to_str:N ##1 }
              \l_@@_tmpa_tl
            \exp_args:No \label { \l_@@_tmpa_tl }
          }
      }
  }
\cs_new_protected:Npn \@@_function_label:nN #1#2
  {
    \bool_if:NF \l_@@_no_label_bool
      {
        \@@_get_hyper_target:eN
          {
            \exp_not:n {#1}
            \bool_if:NT #2 { \tl_to_str:n {TF} }
          }
          \l_@@_tmpa_tl
        \exp_args:No \label { \l_@@_tmpa_tl }
      }
  }
\cs_generate_variant:Nn \@@_function_label:nN { e }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_typeset_dates:}
%   用于显示函数添加/修改时的元数据。
%   此函数必须是可展开的，因为它生成用于对齐的规则。
%    \begin{macrocode}
\cs_new:Npn \@@_typeset_dates:
  {
    \bool_lazy_and:nnF
      { \tl_if_empty_p:N \l_@@_date_added_tl }
      { \tl_if_empty_p:N \l_@@_date_updated_tl }
      { \midrule }
    \tl_if_empty:NF \l_@@_date_added_tl
      {
        \multicolumn { 2 } { @{} r @{} }
          { \scriptsize New: \, \l_@@_date_added_tl } \\
      }

    \tl_if_empty:NF \l_@@_date_updated_tl
      {
        \multicolumn { 2 } { @{} r @{} }
          { \scriptsize Updated: \, \l_@@_date_updated_tl } \\
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_syntax:w, \@@_syntax_end:}
%   实现 \env{syntax} 环境。
%    \begin{macrocode}
\dim_new:N \l_@@_syntax_dim
\cs_new_protected:Npn \@@_syntax:w
  {
    \box_if_empty:NF \g_@@_syntax_box
      { \msg_error:nn { l3doc } { multiple-syntax } }
    \dim_set:Nn \l_@@_syntax_dim
      {
        \textwidth
        \bool_if:NT \l_@@_long_name_bool
          { + 0.75 \marginparwidth - \l_@@_trial_width_dim }
      }
    \hbox_gset:Nw \g_@@_syntax_box
      \small \ttfamily
      \arrayrulecolor{white}
      \begin{tabular} { @{} l @{} }
        \toprule
        \begin{minipage}[t]{\l_@@_syntax_dim}
          \raggedright
          \obeyspaces
          \obeylines
  }
\cs_new_protected:Npn \@@_syntax_end:
  {
        \end{minipage}
      \end{tabular}
      \arrayrulecolor{black}
    \hbox_gset_end:
    \bool_if:NF \l_@@_in_function_bool
      {
        \begin{quote}
          \mode_leave_vertical:
          \box_use_drop:N \g_@@_syntax_box
        \end{quote}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{\env{macro} 环境}
%
% \env{macro} 环境的键值。
% TODO: 提供文档命令以记录键。
%    \begin{macrocode}
\keys_define:nn { l3doc/macro }
  {
    aux .value_forbidden:n = true ,
    aux .code:n =
      {
        \msg_warning:nnnn { l3doc } { deprecated-option }
          { aux } { function/macro }
      } ,
    deprecated .bool_set:N = \l_@@_macro_deprecated_bool , 
    internal .value_forbidden:n = true ,
    internal .code:n =
      { \bool_set_true:N \l_@@_macro_internal_bool } ,
    int .value_forbidden:n = true ,
    int .code:n =
      { \bool_set_true:N \l_@@_macro_internal_bool } ,
    no-user-doc .bool_set:N = \l_@@_macro_nodoc_bool ,
    var .value_forbidden:n = true ,
    var .code:n =
      { \bool_set_true:N \l_@@_macro_var_bool } ,
    TF .value_forbidden:n = true ,
    TF .code:n =
      { \bool_set_true:N \l_@@_macro_TF_bool } ,
    pTF .value_forbidden:n = true ,
    pTF .code:n =
      {
        \bool_set_true:N \l_@@_macro_TF_bool
        \bool_set_true:N \l_@@_macro_pTF_bool
        \bool_set_true:N \l_@@_macro_EXP_bool
        \bool_set_false:N \l_@@_macro_rEXP_bool
      } ,
    noTF .value_forbidden:n = true ,
    noTF .code:n =
      {
        \bool_set_true:N \l_@@_macro_TF_bool
        \bool_set_true:N \l_@@_macro_noTF_bool
      } ,
    EXP .value_forbidden:n = true ,
    EXP .code:n =
      {
        \bool_set_true:N \l_@@_macro_EXP_bool
        \bool_set_false:N \l_@@_macro_rEXP_bool
      } ,
    rEXP .value_forbidden:n = true ,
    rEXP .code:n =
      {
        \bool_set_false:N \l_@@_macro_EXP_bool
        \bool_set_true:N \l_@@_macro_rEXP_bool
      } ,
    tested .code:n =
      {
        \bool_set_true:N \l_@@_macro_tested_bool
      } ,
    added .code:n = {} , % TODO
    updated .code:n = {} , % TODO
    verb .bool_set:N = \l_@@_names_verb_bool ,
    module .tl_set:N = \l_@@_override_module_tl ,
    documented-as .tl_set:N = \l_@@_macro_documented_tl ,
    do-not-index .value_required:n = true ,
    do-not-index .tl_set:N = \l_@@_macro_do_not_index_tl ,
    % do-not-index .default:n = \q_no_value ,
  }
%    \end{macrocode}
%
% \begin{macro}{\@@_macro:nnw}
%   参数是一个 \meta{选项} 的键-值列表和一个逗号分隔的 \meta{名称} 列表，
%   由 \pkg{ltcmd} 以逐字方式读取。在应用 \meta{选项} 之前，先初始化一些变量，
%   然后解析 \meta{名称} 以获取宏名称序列，然后对每个应用 
%   \cs{@@_macro_single:nNN}（这一步比较微妙，因为涉及到 |TF|/|pTF|/|noTF|）。
%   最后在边缘上排版宏名称。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro:nnw #1#2
  {
    \@@_macro_init:
    \tl_set:Nn \l_@@_macro_argument_tl {#2}
    \keys_set:nn { l3doc/macro } {#1}
    \@@_names_get_seq:nN {#2} \l_@@_names_seq
    \@@_names_parse:
    \@@_macro_exclude_index:
    \@@_macro_save_names:
    \@@_names_typeset:
    \@@_macro_dump:
    \@@_macro_reset:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_macro_init:}
%   布尔值保存各种键-值选项，\cs{l_@@_nested_macro_int} 计算当前点周围的 \env{macro} 环境数量（在外部为 $0$）。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_init:
  {
    \int_incr:N \l_@@_nested_macro_int
    \bool_set_false:N \l_@@_macro_deprecated_bool
    \bool_set_false:N \l_@@_macro_internal_bool
    \bool_set_false:N \l_@@_macro_TF_bool
    \bool_set_false:N \l_@@_macro_pTF_bool
    \bool_set_false:N \l_@@_macro_noTF_bool
    \bool_set_false:N \l_@@_macro_EXP_bool
    \bool_set_false:N \l_@@_macro_rEXP_bool
    \bool_set_false:N \l_@@_macro_var_bool
    \bool_set_false:N \l_@@_macro_tested_bool
    \bool_set_false:N \l_@@_names_verb_bool
    \tl_set:Nn \l_@@_override_module_tl { \q_no_value }
    \tl_clear:N \l_@@_macro_documented_tl
    \cs_set_eq:NN \testfile \@@_print_testfile:n
    \box_clear:N \l_@@_macro_index_box
    \vbox_set:Nn \l_@@_macro_box
      {
        \hbox:n
          {
            \strut
            \int_compare:nNnT \l_@@_macro_int = 0 { \@@_target: }
          }
        \vskip \int_eval:n { \l_@@_macro_int - 1 } \baselineskip
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_macro_reset:}
%   确保被强制模块的宏内的 \cs{cs} 命令不受影响。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_reset:
  {
    \tl_set:Nn \l_@@_override_module_tl { \q_no_value }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_macro_save_names:}
%   在一组 \env{macro} 环境中定义的名称列表最终用于显示其文档的页面。如果给出了 
%   |documented-as| 键，则使用该键，否则在 \cs{l_@@_names_block_tl} 中查找名
%   称。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_save_names:
  {
    \tl_if_empty:NTF \l_@@_macro_documented_tl
      { \@@_names_block_base_map:N \@@_macro_save_names_aux:n }
      {
        \seq_gput_right:Ne \g_@@_nested_names_seq
          { \tl_to_str:N \l_@@_macro_documented_tl }
      }
  }
\cs_new_protected:Npn \@@_macro_save_names_aux:n #1
  { \seq_gput_right:Nn \g_@@_nested_names_seq {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_macro_exclude_index:}
%   在 \env{macrocode} 环境中的某些控制序列不应该被索引，原因各不相同。此宏解析 
%   |do-not-index| 选项的参数，并从索引中局部移除给定的宏。
%
%   \env{macro} 的可选参数不使用逐字的类别码扫描，所以我们使用 
%   \cs{tl_set_rescan:NnV} 以与 \cs{DoNotIndex} 相同的类别码重新扫描命令。扫
%   描的标记列表包含控制序列后面的空格，在使用 \cs{DoNotIndex} 时不存在。由于 
%   \cs{seq_set_from_clist:Nn} 移除了项目周围的空格，我们可以滥用这一点和 
%   \cs{seq_use:Nn} 来规范化每个项目。然后 \cs{DoNotIndex} 就可以起作用了。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_exclude_index:
  {
    \tl_if_empty:NF \l_@@_macro_do_not_index_tl
      {
        \tl_set_rescan:NnV \l_@@_macro_do_not_index_tl
          { \MakePrivateLetters \catcode`\\12 }
          \l_@@_macro_do_not_index_tl
        \exp_args:NNV \seq_set_from_clist:Nn
          \l_@@_tmpa_seq \l_@@_macro_do_not_index_tl
        \__kernel_tl_set:Ne \l_@@_macro_do_not_index_tl
          { \seq_use:Nn \l_@@_tmpa_seq { , } }
        \exp_args:NV \DoNotIndex \l_@@_macro_do_not_index_tl
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_macro_dump:}
%   它调用了 |\makelabel{}|
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_dump:
  {
    \topsep\MacroTopsep
    \trivlist
    \cs_set:Npn \makelabel ##1
      {
        \llap
          {
            \hbox_unpack_drop:N \l_@@_macro_index_box
            \vtop to \baselineskip
              {
                \vbox_unpack_drop:N \l_@@_macro_box
                \vss
              }
          }
      }
    \item [ ]
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_macro_typeset_block:nN}
%   用于排版宏及其变体。|#1| 是宏名称，|#2| 是控制是否添加|TF|的布尔值。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_typeset_block:nN #1#2
  {
    \@@_macro_single:nNN {#1} \c_true_bool #2
    \seq_if_empty:NF \g_@@_variants_seq
      {
        \@@_macro_typeset_variant_list:eN
          { \@@_get_function_name:n {#1} } #2
      }
  }
\cs_new_protected:Npn \@@_macro_typeset_variant_list:nN #1#2
  {
    \seq_map_inline:Nn \g_@@_variants_seq
      { \@@_macro_single:nNN { #1 : ##1 } \c_false_bool #2 }
  }
\cs_generate_variant:Nn \@@_macro_typeset_variant_list:nN { e }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_macro_single:nNN}
%   参数是 |#1|（不含|TF|的宏名称），|#2| 是确定是否索引的布尔值，|#3| 是是否添加|TF|的布尔值。
%   让我们开始操作 \cls{doc} 的 \env{macro} 环境。
%   参见 \file{doc.dtx} 以了解原始环境的详细解释。它被相当“热情地”注释了。
%   \begin{arguments}
%     \item 宏/函数/等名称；输入已经经过了净化。
%   \end{arguments}
%   对 \cs{saved@macroname} 和 \cs{saved@indexname} 的赋值是为了 \pkg{doc} 的 \cs{changes} 机制。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_single:nNN #1#2#3
  {
    \tl_set:Nn \saved@macroname {#1}
    \@@_macro_typeset_one:nN {#1} #3
    \bool_if:NT #3 { \DoNotIndex {#1} }
    \exp_args:Ne \@@_macro_index:nN
      { #1 \bool_if:NT #3 { \tl_to_str:n { TF } } }
      #2
  }
\cs_new_protected:Npn \@@_macro_index:nN #1#2
  {
    \DoNotIndex {#1}
    \bool_if:NT #2
      {
        \bool_lazy_any:nF
          {
            { \@@_if_macro_internal_p:n {#1} }
            { \l_@@_macro_deprecated_bool }
            { \l_@@_macro_nodoc_bool }
          }
          { \seq_gput_right:Nn \g_doc_macros_seq {#1} }
        \hbox_set:Nw \l_@@_macro_index_box
          \hbox_unpack_drop:N \l_@@_macro_index_box
          \int_gincr:N \c@CodelineNo
          \@@_special_index:nn {#1} { main }
          \int_gdecr:N \c@CodelineNo
        \exp_args:NNNo \hbox_set_end:
          \tl_set:Nn \saved@indexname { \l_@@_index_key_tl }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_macro_typeset_one:nN}
%   长时间以来，\cls{l3doc} 将宏名称作为嵌套的 \tn{trivlist} 中的标签收集起来，但是这些并没有用 \tn{endtrivlist} 正确关闭。
%   而且，它与 \pkg{hyperref} 的目标产生了令人惊讶的交互方式。现在，我们手动在盒子 \cs{l_@@_macro_box} 中收集排版的宏名称。
%   固定大小的空格 |\MacroFont\ | 可以被可定制的水平空格所取代；对所有宏而言，重要的是它们都是相同的。
%   |#1| 是宏名称，|#2| 是否添加 |TF|。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_typeset_one:nN #1#2
  {
    \vbox_set:Nn \l_@@_macro_box
      {
        \vbox_unpack_drop:N \l_@@_macro_box
        \hbox { \llap { \@@_print_macroname:nN {#1} #2
            \MacroFont \
        } }
      }
    \int_incr:N \l_@@_macro_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_print_macroname:nN}
%   在名称中，空格被替换为其他空格，以确保它们能够显示（如果有的话）。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_print_macroname:nN #1#2
  {
    \strut
    \@@_get_hyper_target:eN
      {
        \exp_not:n {#1}
        \bool_if:NT #2 { \tl_to_str:n {TF} }
      }
      \l_@@_tmpa_tl
    \cs_if_exist:cTF { r@ \l_@@_tmpa_tl }
      { \exp_last_unbraced:NNo \hyperref [ \l_@@_tmpa_tl ] }
      { \use:n }
      {
        \int_compare:nTF { \str_count:n {#1} <= 28 }
          { \MacroFont } { \MacroLongFont }
        \tl_set:Nn \l_@@_tmpa_tl {#1}
        \tl_replace_all:NnV \l_@@_tmpa_tl
          { ~ } \c_catcode_other_space_tl
        \@@_macroname_prefix:o \l_@@_tmpa_tl
        \@@_macroname_suffix:N #2
      }
  }
\cs_new_protected:Npn \@@_macroname_prefix:n #1
  {
    \@@_if_macro_internal:nTF {#1}
      { \@@_typeset_aux:n {#1} } {#1}
  }
\cs_generate_variant:Nn \@@_macroname_prefix:n { o }
\cs_new_protected:Npn \@@_macroname_suffix:N #1
  { \bool_if:NTF #1 { \@@_typeset_TF: } { } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\MacroLongFont}
%    \begin{macrocode}
\providecommand \MacroLongFont
  {
    \fontfamily{lmtt}\fontseries{lc}\small
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_print_testfile:n, \@@_print_testfile_aux:n}
%   用于显示某个宏是否有测试。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_print_testfile:n #1
  {
    \bool_set_true:N \l_@@_macro_tested_bool
    \tl_if_eq:nnF {#1} {*}
      {
        \seq_if_in:NnF \g_@@_testfiles_seq {#1}
          {
            \seq_gput_right:Nn \g_@@_testfiles_seq {#1}
            \par
            \@@_print_testfile_aux:n {#1}
          }
      }
  }
\cs_new_protected:Npn \@@_print_testfile_aux:n #1
  {
    \footnotesize
    (
    \textit
      {
        The~ test~ suite~ for~ this~ command,~
        and~ others~ in~ this~ file,~ is~ \textsf{#1}
      }.
    )\par
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TestFiles}
%    \begin{macrocode}
\DeclareDocumentCommand \TestFiles {m}
  {
    \par
    \textit
      {
        The~ following~ test~ files~ are~
        used~ for~ this~ code:~ \textsf{#1}.
      }
    \par \ignorespaces
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UnitTested}
%    \begin{macrocode}
\DeclareDocumentCommand \UnitTested { } { \testfile* }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TestMissing}
%    \begin{macrocode}
\DeclareDocumentCommand \TestMissing { m }
  { \@@_test_missing:n {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_test_missing:n}
%   \cs{g_@@_missing_tests_prop} 中的键是以一个 \env{macro} 环境的参数给出的一组宏的列表。
%   值是文件名和关于缺少测试的注释的对。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_test_missing:n #1
  {
    \@@_test_missing_aux:Nen
      \g_@@_missing_tests_prop
      { \seq_use:Nn \l_@@_names_seq { , } }
      { { \g_file_curr_name_str \c_space_tl (#1) } }
  }
\cs_new_protected:Npn \@@_test_missing_aux:Nnn #1#2#3
  {
    \prop_get:NnNTF #1 {#2} \l_@@_tmpa_tl
      { \tl_put_right:Nn \l_@@_tmpa_tl { , #3 } }
      { \tl_set:Nn \l_@@_tmpa_tl {#3} }
    \prop_put:Nno #1 {#2} \l_@@_tmpa_tl
  }
\cs_generate_variant:Nn \@@_test_missing_aux:Nnn { Ne }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_macro_end:}
%   现在对于任何人来说都太晚了，来为这个宏声明一个测试文件，所以我们现在可以检查这个宏是否经过了测试。
%   如果正在结束的 \env{macro} 环境是最外层的环境，则用 \tn{texttt}（如果有的话，附加 |TF|）包裹每个宏，并显示两个信息：
%   这结束了一些宏的定义，并且它们被记录在某一页上。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_end:
  {
    \endtrivlist
    \@@_macro_end_check_tested:
    \int_compare:nNnT \l_@@_nested_macro_int = 1
      { \@@_macro_end_style:n { \@@_print_end_definition: } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_macro_end_check_tested:}
%   如果发出了 |checktest| 选项，并且该宏不是辅助的也不是变量（并且它没有测试），则将其添加到未经测试的宏序列中。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_end_check_tested:
  {
    \bool_lazy_all:nT
     {
       { \g_@@_checktest_bool }
       { ! \l_@@_macro_var_bool }
       { ! \l_@@_macro_tested_bool }
     }
     {
       \seq_set_filter:NNn \l_@@_tmpa_seq \l_@@_names_seq
         { ! \@@_if_macro_internal_p:n {##1} }
       \seq_gput_right:Ne \g_@@_not_tested_seq
         {
           \seq_use:Nn \l_@@_tmpa_seq { , }
           \bool_if:NTF \l_@@_macro_pTF_bool {~(pTF)}
             { \bool_if:NT \l_@@_macro_TF_bool {~(TF)} }
         }
     }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_macro_end_style:n}
%   顶层 \env{macro} 环境结束时额外信息的样式。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_end_style:n #1
  {
    \nobreak \noindent
    { \footnotesize ( \emph{#1} ) \par }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_print_end_definition:,
%     \@@_macro_end_wrap_item:n,
%     \@@_print_documented:
%   }
%   将每个项目用 \tn{texttt} 包围起来，同时将 |_|
%   替换为 \tn{_}。然后通过 \cs{seq_use:Nnnn} 列出宏名称，除非太多了。
%   最后，如果宏既不是辅助的也不是内部的，则添加指向其文档位置的链接。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_macro_end_wrap_item:n #1
  {
    \tl_set:Nn \l_@@_tmpa_tl {#1}
    \tl_replace_all:NVn \l_@@_tmpa_tl
      \c_underscore_str { \_ }
    \texttt { \l_@@_tmpa_tl }
  }
\cs_new_protected:Npn \@@_print_end_definition:
  {
    \seq_set_map:NNn \l_@@_tmpa_seq
      \g_@@_nested_names_seq
      { \@@_macro_end_wrap_item:n {##1} }
    End~ of~ definition~ for~
    \int_compare:nTF { \seq_count:N \l_@@_tmpa_seq <= 3 }
      {
        \seq_use:Nnnn \l_@@_tmpa_seq
          { \,~and~ } { \,,~ } { \,,~and~ }
      }
      { \seq_item:Nn \l_@@_tmpa_seq {1}\,~and~others }
    \@.
    \@@_print_documented:
  }
\cs_new_protected:Npn \@@_print_documented:
  {
    \seq_gset_filter:NNn \g_@@_nested_names_seq
      \g_@@_nested_names_seq
      {
        ! \bool_lazy_any_p:n
          {
            { \@@_if_macro_internal_p:n {##1} }
            { \l_@@_macro_deprecated_bool }
            { \l_@@_macro_nodoc_bool }
          }
      }
    \seq_if_empty:NF \g_@@_nested_names_seq
      {
        \int_set:Nn \l_@@_tmpa_int
          { \seq_count:N \g_@@_nested_names_seq }
        \int_compare:nNnTF \l_@@_tmpa_int = 1 {~This~} {~These~}
        \bool_if:NTF \l_@@_macro_var_bool {variable} {function}
        \int_compare:nNnTF \l_@@_tmpa_int = 1 {~is~} {s~are~}
        documented~on~page~
        \@@_get_hyper_target:eN
          { \seq_item:Nn \g_@@_nested_names_seq { 1 } }
          \l_@@_tmpa_tl
        \exp_args:Ne \pageref { \l_@@_tmpa_tl } .
      }
    \seq_gclear:N \g_@@_nested_names_seq
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{杂项}
%
% \begin{macro}{\DescribeOption}
%   用于描述包选项的功能：为保持一致性而保留，但针对 \pkg{doc} v3 进行了更新。
%    \begin{macrocode}
\NewDocElement[idxtype = option, idxgroup = options]{Option}{optionenv}  
%    \end{macrocode}
% \end{macro}
%
% 这里有一些额外标记的定义，有助于构建您的文档结构。
%
% \begin{environment}{danger}
% \begin{environment}{ddanger}
%   \begin{syntax}
%     |\begin{[d]danger}|\\
%       dangerous code\\
%     |\end{[d]danger}|
%   \end{syntax}
%   \begin{danger}
%     提供了来自 \TeX{}book 中所知的危险符号。
%   \end{danger}
%   来自 |manfnt| 字体的实际字符：
%    \begin{macrocode}
\font \manual = manfnt \scan_stop:
\cs_gset:Npn \dbend { {\manual\char127} }
%    \end{macrocode}
%
% 定义单个危险符号。每当包中有可能使用的特性比较棘手时使用它。
% FIXME：在与宏定义组合使用时必须修复。
%    \begin{macrocode}
\newenvironment {danger}
  {
    \begin{trivlist}\item[]\noindent
    \begingroup\hangindent=2pc\hangafter=-2
    \cs_set:Npn \par{\endgraf\endgroup}
    \hbox to0pt{\hskip-\hangindent\dbend\hfill}\ignorespaces
  }
  {
    \par\end{trivlist}
  }
%    \end{macrocode}
%
% \begin{ddanger}
%   如果有一些东西在错误使用时可能会导致严重问题，请使用双重危险符号。最好普通用户不要了解此类情况。
% \end{ddanger}
%    \begin{macrocode}
\newenvironment {ddanger}
  {
    \begin{trivlist}\item[]\noindent
    \begingroup\hangindent=3.5pc\hangafter=-2
    \cs_set:Npn \par{\endgraf\endgroup}
    \hbox to0pt{\hskip-\hangindent\dbend\kern2pt\dbend\hfill}\ignorespaces
  }{
      \par\end{trivlist}
  }
%    \end{macrocode}
% \end{environment}
% \end{environment}
%
% \subsubsection{NB 和 NOTE}
%
% 这些宏旨在添加到源文件中的额外注释，不进行排版。
%
% \begin{macro}{\NB}
% \NB{wspr}{this is what I think about this!}
% \begin{verbatim}
%   \NB{wspr}{this is what I think about this!}
% \end{verbatim}
%    \begin{macrocode}
\bool_if:NTF \g_@@_show_notes_bool
  {
    \NewDocumentCommand\NB{mm}
      {
        (\emph{Note}\footnote{\ttfamily [#1]:~\detokenize{#2}})
      }
  }
  {
    \NewDocumentCommand\NB{mm}{}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{NOTE}
% \begin{NOTE}{wspr}
%   this is what I #$%& think about this!
% \end{NOTE}
% \begin{verbatim}
%   \begin{NOTE}{wspr}
%     this is what I #$%& think about this!
%   \end{NOTE}
% \end{verbatim}
%    \begin{macrocode}
\bool_if:NTF \g_@@_show_notes_bool
  {
    \NewDocumentEnvironment{NOTE}{m}
      {
        \par\noindent (\emph{Note}~[\texttt{#1}]:\par
        \verbatim
      }
      {
        \endverbatim
        \par\noindent \emph{Note~end})\par
      }
  }
  {
    \NewDocumentEnvironment{NOTE}{m}{\comment}{\endcomment}
  }
%    \end{macrocode}
% \end{environment}
%
% \subsection{脚注支持}
% \env{function} 和 \env{variable} 环境是盒子，因此会失去脚注。以下实现了对其的支持。
% 目前依赖于 hyperref 内部机制来获取正确的目标。
% 
%    \begin{macrocode}
\providecommand\Hy@footnote@currentHref{}
\prop_new:N\g_@@_fnmark_prop
\cs_new_protected:Npn \@@_fn_store: 
 { 
   \prop_gput:Nee\g_@@_fnmark_prop 
     {fn\int_use:N\c@footnote}{{\Hy@footnote@currentHref}{\int_use:N\c@footnote}}
 }
\cs_new_protected:Npn \@@_fn_restore:n  #1
 {
   \prop_get:NnN \g_@@_fnmark_prop {fn#1}\l_@@_tmpa_tl
   \tl_gset:Ne\Hy@footnote@currentHref
     {\exp_last_unbraced:NV\use_i:nn \l_@@_tmpa_tl }
   \setcounter{footnote}{\exp_last_unbraced:NV\use_ii:nn \l_@@_tmpa_tl}
 }  

\cs_generate_variant:Nn \hook_gput_next_code:nn {ne}
\cs_new_protected:Npn \@@_fn_footnote:nn #1 #2
  {
    \footnotemark
    \@@_fn_store: 
    \hook_gput_next_code:ne {env/#1/after}
      {\exp_not:N\@@_fn_restore:n{\int_use:N\c@footnote}{\exp_not:n{\footnotetext{#2}}}}}

\AddToHook{env/function/begin}{\def\footnote{\@@_fn_footnote:nn{function}}}
\AddToHook{env/variable/begin}{\def\footnote{\@@_fn_footnote:nn{variable}}} 
%    \end{macrocode}
%
% \subsection{建立模板的文档}
%
%    \begin{macrocode}
\newenvironment{TemplateInterfaceDescription}[1]
  {
    \subsection{The~object~type~`#1'}
    \begingroup
    \@beginparpenalty\@M
    \description
    \def\TemplateArgument##1##2{\item[Arg:~##1]##2\par}
    \def\TemplateSemantics
      {
        \enddescription\endgroup
        \subsubsection*{Semantics:}
      }
  }
  {
    \par\bigskip
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\newenvironment{TemplateDescription}[2]
  {
    \subsection{The~template~`#2'~(object~type~#1)}
    \subsubsection*{Attributes:}
    \begingroup
    \@beginparpenalty\@M
    \description
    \def\TemplateKey##1##2##3##4
      {
        \item[##1~(##2)]##3%
        \ifx\TemplateKey##4\TemplateKey\else
%         \hskip0ptplus3em\penalty-500\hskip 0pt plus 1filll Default:~##4%
          \hfill\penalty500\hbox{}\hfill Default:~##4%
          \nobreak\hskip-\parfillskip\hskip0pt\relax
        \fi
        \par
      }
    \def\TemplateSemantics
      {
        \enddescription\endgroup
        \subsubsection*{Semantics~\&~Comments:}
      }
  }
  { \par \bigskip }
%    \end{macrocode}
%
%    \begin{macrocode}
\newenvironment{InstanceDescription}[4][xxxxxxxxxxxxxxx]
  {
    \subsubsection{The~instance~`#3'~(template~#2/#4)}
    \subsubsection*{Attribute~values:}
    \begingroup
    \@beginparpenalty\@M
    \def\InstanceKey##1##2{\>\textbf{##1}\>##2\\}
    \def\InstanceSemantics{\endtabbing\endgroup
      \vskip-30pt\vskip0pt
      \subsubsection*{Layout~description~\&~Comments:}}
    \tabbing
    xxxx\=#1\=\kill
  }
  { \par \bigskip }
%    \end{macrocode}
%
% \subsection{继承文档}
%
% 这里的代码来自于 \pkg{doc}，去除了注释并转换成了 \pkg{expl3} 语法。在各个地方增加了新功能。
%
% \begin{macro}
%   {\StopEventually, \MaybeStop, \Finale, \AlsoImplementation, \OnlyDescription}
% \begin{variable}{\g_@@_finale_tl}
% TODO：彻底移除这四个命令，并记录最好使用 \env{documentation} 和 \env{implementation} 环境。
%    \begin{macrocode}
\DeclareDocumentCommand \OnlyDescription { }
  { \bool_gset_false:N \g_@@_typeset_implementation_bool }
\DeclareDocumentCommand \AlsoImplementation { }
  { \bool_gset_true:N \g_@@_typeset_implementation_bool }
\DeclareDocumentCommand \StopEventually { m }
  {
    \bool_if:NTF \g_@@_typeset_implementation_bool
      {
        \@bsphack
        \tl_gset:Nn \g_@@_finale_tl { #1 \check@checksum }
        \init@checksum
        \@esphack
      }
      { #1 \endinput }
  }
%    \end{macrocode}
% 我们还需要支持 doc V3 的 \cs{MaybeStop}（可能不存在）。
%    \begin{macrocode}
\cs_if_exist:NT \MaybeStop  
   { \RenewCommandCopy \MaybeStop \StopEventually }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareDocumentCommand \Finale { }
  { \tl_use:N \g_@@_finale_tl }
\tl_new:N \g_@@_finale_tl
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% \begin{macro}{\@@_input:n}
%   对文件进行输入，并进行一些设置：在文件中的第一个 |<@@=|\meta{module}|>| 行之前，模块名应为空。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_input:n #1
  {
    \tl_gclear:N \g_@@_module_name_tl
    \MakePercentIgnore
    \input{#1}
    \MakePercentComment
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DocInput}
%   从 \pkg{doc} 修改而来，可以接受逗号分隔的输入（文件名里有逗号吗？）。
%    \begin{macrocode}
\DeclareDocumentCommand \DocInput { m }
  {
    \clist_map_inline:nn {#1}
      {
        \clist_put_right:Nn \g_docinput_clist {##1}
        \@@_input:n {##1}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DocInputAgain}
%   使用 \cs{g_docinput_clist} 重新输入到目前为止已经 \tn{DocInput} 进来的内容。可以多次使用。
%    \begin{macrocode}
\DeclareDocumentCommand \DocInputAgain { }
  { \clist_map_function:NN \g_docinput_clist \@@_input:n }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DocInclude}
%   几乎与 \tn{include} 完全相同，但是使用 \tn{DocInput} 处理 \file{.dtx} 文件，而不是处理 \file{.tex} 文件。
%
%    \begin{macrocode}
\NewDocumentCommand \DocInclude { m }
  {
    \relax\clearpage
    \docincludeaux
    \IfFileExists{#1.fdd}
      { \cs_set:Npn \currentfile{#1.fdd} }
      { \cs_set:Npn \currentfile{#1.dtx} }
    \int_compare:nNnTF \@auxout = \@partaux
      { \@latexerr{\string\include\space cannot~be~nested}\@eha }
      { \@docinclude {#1} }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_gset:Npn \@docinclude #1
  {
    \clearpage
    \immediate\write\@mainaux{\string\@input{#1.aux}}
    \@tempswatrue
    \if@partsw
      \@tempswafalse
      \cs_set:Npe \@tempb {#1}
      \clist_map_inline:Nn \@partlist
        {
          \if_meaning:w \@tempa \@tempb
            \@tempswatrue
          \fi:
        }
    \fi
    \if@tempswa
      \cs_set_eq:NN \@auxout                 \@partaux
      \immediate\openout\@partaux #1.aux
      \immediate\write\@partaux{\relax}
      \cs_set_eq:NN \@ltxdoc@PrintIndex      \PrintIndex
      \cs_set_eq:NN \PrintIndex              \relax
      \cs_set_eq:NN \@ltxdoc@PrintChanges    \PrintChanges
      \cs_set_eq:NN \PrintChanges            \relax
      \cs_set_eq:NN \@ltxdoc@theglossary     \theglossary
      \cs_set_eq:NN \@ltxdoc@endtheglossary  \endtheglossary
      \part{\currentfile}
      {
        \cs_set_eq:NN \ttfamily\relax
        \cs_gset:Npe \filekey
          { \filekey,~ \thepart = { \ttfamily \currentfile } }
      }
      \DocInput{\currentfile}
      \cs_set_eq:NN \PrintIndex              \@ltxdoc@PrintIndex
      \cs_set_eq:NN \PrintChanges            \@ltxdoc@PrintChanges
      \cs_set_eq:NN \theglossary             \@ltxdoc@theglossary
      \cs_set_eq:NN \endtheglossary          \@ltxdoc@endtheglossary
      \clearpage
      \@writeckpt{#1}
      \immediate \closeout \@partaux
    \else
      \@nameuse{cp@#1}
    \fi
    \cs_set_eq:NN \@auxout \@mainaux
  }
%    \end{macrocode}
%
% 在这里，|MMMMI|（用于页面引用）和 |MMMMV|（用于代码行引用）被 |makeindex| 
% 解释为大写罗马数字页码，应该足够大，以避免与大写罗马数字页码的其他用途发生冲
% 突。 \cs{@wrindex} 和 \cs{codeline@wrindex} 之间有两个细微差别，第一个必
% 须延迟写入，因为页面号尚不知道，第二个必须关闭一组并完成一些空间调整。
% 
% 我们还提供了适用于我们用途的版本，引用的方式是
%    \begin{macrocode}
\cs_gset_protected:Npn \@wrindex #1
  {
    \protected@write \@indexfile {}
      { \string \indexentry {#1} { MMMMI - \thepage } }
    \endgroup \@esphack
  }
\cs_gset_protected:Npn \codeline@wrindex #1
  {
    \immediate\write\@indexfile
      {
        \string\indexentry{#1}
          { MMMMV - \filesep \int_use:N \c@CodelineNo }
      }
  }
\tl_gclear:N \filesep
\cs_new_protected:Npn \@@_index_page_hc:nn #1#2
  {
    \protected@write \@indexfile {}
      {
        \string \indexentry { #1 \encapchar hdpindex{#2} }
          { MMMMI - \thepage }
      }
  }
\cs_new_protected:Npn \@@_index_codeline_hc:nn #1#2
  {
    \immediate\write\@indexfile
      {
        \string \indexentry { #1 \encapchar hdclindex{\the\c@HD@hypercount}{#2} }
          { MMMMV - \filesep \int_use:N \c@CodelineNo - MMMD - \the\c@HD@hypercount - M }
      }
  }
%    \end{macrocode}
% 每行代码都已经有一个单独的 |HD.xx| 目标了。最好是每行代码都有一个 
% |CL.\the\c@CodelineNo| 目标，并且将 |hdclindex{\the\c@HD@hypercount}| 
% 更改为更接近 |hdpindex| 的机制，但我们需要更好地理解不同类型的索引，并且对于
% 索引 |\{| 和 |\}| 有一些微妙之处。
% \end{macro}
%
% \begin{macro}{\docincludeaux}
%    \begin{macrocode}
\cs_gset:Npn \docincludeaux
  {
    \tl_set:Nn \thepart { \alphalph { part } }
    \tl_set:Nn \filesep { \thepart - }
    \cs_set_eq:NN \filekey \use_none:n
    \tl_gput_right:Nn \index@prologue
      {
        \cs_gset:Npn \@oddfoot
          {
            \parbox { \textwidth }
              {
                \strut \footnotesize
                \raggedright { \bfseries File~Key: } ~ \filekey
              }
          }
        \cs_set_eq:NN \@evenfoot \@oddfoot
      }
    \cs_gset_eq:NN \docincludeaux \relax
    \cs_gset:Npn \@oddfoot
      {
        \cs_if_exist:cTF { ver @ \currentfile }
          { File~\thepart :~{\ttfamily\currentfile}~ }
          {
            \GetFileInfo{\currentfile}
            File~\thepart :~{\ttfamily\filename}~
            Date:~\ExplFileDate\ % space
            Version~\ExplFileVersion
          }
        \hfill \thepage
      }
    \cs_set_eq:NN \@evenfoot \@oddfoot
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{\env{macrocode} 环境}
%
% \begin{macro}{\xmacro@code, \@@_xmacro_code:n, \@@_xmacro_code:w}
%   以一种独特的方式钩入 \texttt{macrocode} 环境：
%   \tn{xmacro@code} 负责获取（和标记化）环境的主体。重新定义它以将其获取的内容传递给 \cs{@@_xmacro_code:n}。这个新宏将所有的 |@@| 替换为适当的模块名称。唯一的例外是 |<@@=|\meta{module}|>| 行本身，其中 |@@| 不应修改。事实上，我们搜索这样的行来自动设置模块名称。我们需要小心：在下面的代码中不应出现任何 |<@@=|，因为 \pkg{l3doc} 也是使用此代码排版的。
%   每次找到 |<@@=|，替换它后面的代码中的 \meta{module}，更新 \meta{module}，并循环检查是否有进一步的 |<@@=| 出现。
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_other:N \^^A
  \char_set_catcode_active:N \^^S
  \char_set_catcode_active:N \^^B
  \char_set_catcode_other:N \^^L
  \char_set_catcode_other:N \^^R
  \char_set_lccode:nn { `\^^A } { `\% }
  \char_set_lccode:nn { `\^^S } { `\  }
  \char_set_lccode:nn { `\^^B } { `\\ }
  \char_set_lccode:nn { `\^^L } { `\{ }
  \char_set_lccode:nn { `\^^R } { `\} }
  \tex_lowercase:D
    {
      \group_end:
      \cs_set_protected:Npn \xmacro@code
          #1 ^^A ^^S^^S^^S^^S ^^Bend ^^Lmacrocode^^R
        { \@@_xmacro_code:n {#1} \end{macrocode} }
    }
\group_begin:
  \char_set_catcode_active:N \<
  \char_set_catcode_active:N \>
  \cs_new_protected:Npn \@@_xmacro_code:n #1
    {
      \tl_clear:N \l_@@_tmpa_tl
      \tl_if_in:nnTF {#1} { < @ @ = }
        { \@@_xmacro_code:w #1 < @ @ = \q_recursion_tail > \q_recursion_stop }
        {
          \tl_set:Nn \l_@@_tmpa_tl {#1}
          \@@_detect_internals:N \l_@@_tmpa_tl
          \@@_replace_at_at:N \l_@@_tmpa_tl
          \tl_use:N \l_@@_tmpa_tl
        }
    }
  \cs_new_protected:Npn \@@_xmacro_code:w #1 < @ @ = #2 >
    {
      % Add code before <@@@@=...>
      \tl_set:Nn \l_@@_tmpb_tl {#1}
      \@@_detect_internals:N \l_@@_tmpb_tl
      \@@_replace_at_at:N \l_@@_tmpb_tl
      \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
      % Check for \q_recursion_tail
      \quark_if_recursion_tail_stop_do:nn {#2}
        { \tl_use:N \l_@@_tmpa_tl }
      % Change module name and add <@@@@=#2> to typeset output
      \tl_gset:Nn \g_@@_module_name_tl {#2}
      \tl_put_right:Nn \l_@@_tmpa_tl { < \text { \verbatim@font @ @ = #2 } > }
      % Loop
      \@@_xmacro_code:w
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \subsection{文档结束时}
%
% 打印所有已定义和已记录的宏/函数。
%
%    \begin{macrocode}
\iow_new:N \g_@@_func_iow
%    \end{macrocode}
%
%    \begin{macrocode}
\tl_new:N \l_@@_doc_def_tl
\tl_new:N \l_@@_doc_undef_tl
\tl_new:N \l_@@_undoc_def_tl
\tl_const:Nn \c_@@_iow_separator_tl { ---- }
\tl_const:Nn \c_@@_iow_midrule_tl  { -- }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_show_functions_defined:
  {
    \bool_lazy_and:nnT
      { \g_@@_typeset_implementation_bool } { \g_@@_checkfunc_bool }
      {
        \iow_term:e { \c_@@_iow_separator_tl \iow_newline: }
        \iow_open:Nn \g_@@_func_iow { \c_sys_jobname_str .cmds }

        \tl_clear:N \l_@@_doc_def_tl
        \tl_clear:N \l_@@_doc_undef_tl
        \tl_clear:N \l_@@_undoc_def_tl
        \seq_gremove_duplicates:N \g_doc_functions_seq
        \seq_gremove_duplicates:N \g_doc_macros_seq
        \seq_map_inline:Nn \g_doc_functions_seq
          {
            \seq_if_in:NnTF \g_doc_macros_seq {##1}
              {
                \tl_put_right:Ne \l_@@_doc_def_tl
                  { \iow_newline: > ~ ##1 }
              }
              {
                \tl_put_right:Ne \l_@@_doc_undef_tl
                  { \iow_newline: ! ~ ##1 }
              }
          }
        \seq_map_inline:Nn \g_doc_macros_seq
          {
            \seq_if_in:NnF \g_doc_functions_seq {##1}
              {
                \tl_put_right:Ne \l_@@_undoc_def_tl
                  { \iow_newline: ? ~ ##1 }
              }
          }
        \@@_functions_typeout:nN
          {
            Functions~both~documented~and~defined: \iow_newline:
            (In~order~of~being~documented)
          }
          \l_@@_doc_def_tl
        \@@_functions_typeout:nN
          { Functions~documented~but~not~defined: }
          \l_@@_doc_undef_tl
        \@@_functions_typeout:nN
          { Functions~defined~but~not~documented: }
          \l_@@_undoc_def_tl

        \iow_close:N \g_@@_func_iow
        \iow_term:e { \c_@@_iow_separator_tl }
      }
  }
\AtEndDocument { \@@_show_functions_defined: }
%    \end{macrocode}
%
% TODO: 用 \cs{iow_term:e}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_functions_typeout:nN #1#2
  {
    \tl_if_empty:NF #2
      {
        \iow_now:Ne \g_@@_func_iow
          {
            \c_@@_iow_midrule_tl \iow_newline:
            #1 \iow_newline:
            \c_@@_iow_midrule_tl
            #2
          }
        \tl_clear:N #2
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_show_not_tested:
  {
    \bool_if:NT \g_@@_checktest_bool
      {
        \tl_clear:N \l_@@_tmpa_tl
        \prop_if_empty:NF \g_@@_missing_tests_prop
          {
            \cs_set:Npn \@@_tmpa:w ##1##2
              {
                \iow_newline:
                \space\space\space\space \exp_not:n {##1}
                \clist_map_function:nN {##2} \@@_tmpb:w
              }
            \cs_set:Npn \@@_tmpb:w ##1
              {
                \iow_newline:
                \space\space\space\space\space\space * ~ ##1
              }
            \tl_put_right:Ne \l_@@_tmpa_tl
              {
                \iow_newline: \iow_newline:
                The~ following~ macro(s)~ have~ incomplete~ tests:
                \iow_newline:
                \prop_map_function:NN
                  \g_@@_missing_tests_prop \@@_tmpa:w
              }
          }
        \seq_if_empty:NF \g_@@_not_tested_seq
          {
            \cs_set:Npn \@@_tmpa:w ##1
              { \clist_map_function:nN {##1} \@@_tmpb:w }
            \cs_set:Npn \@@_tmpb:w ##1
              {
                \iow_newline:
                \space\space\space\space ##1
              }
            \tl_put_right:Ne \l_@@_tmpa_tl
              {
                \iow_newline:
                \iow_newline:
                The~ following~ macro(s)~ do~ not~ have~ any~ tests:
                \iow_newline:
                \seq_map_function:NN
                  \g_@@_not_tested_seq \@@_tmpa:w
              }
          }
        \tl_if_empty:NF \l_@@_tmpa_tl
          {
            \int_set:Nn \l_@@_tmpa_int { \tex_interactionmode:D }
            \errorstopmode
            \ClassError { l3doc } { \l_@@_tmpa_tl } { }
            \int_set:Nn \tex_interactionmode:D { \l_@@_tmpa_int }
          }
      }
  }
\AtEndDocument { \@@_show_not_tested: }
%    \end{macrocode}
%
% \subsection{索引}
%
% \subsubsection{必要的修补}
%
% 以下内容对于设置 \pkg{hyperref} 的目标很有用，例如为了索引的目的。
% 与 \pkg{hypdoc} 不同的是，我们不尝试保存 PDF 目标，因为这会在早期运行时产生太多 \pdfTeX{} 警告。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_target:
  {
    \mode_leave_vertical:
    \group_begin:
      \HD@savedestfalse \HD@target
    \group_end:
  }
%    \end{macrocode}
% 强制在每行代码上创建目标。
%    \begin{macrocode}
\cs_set_nopar:Npe \theCodelineNo
  {
    \group_begin:
      \exp_not:N \HD@savedestfalse
      \exp_not:o \theCodelineNo
    \group_end:
  }
%    \end{macrocode}
%
% 在目录（以及由 \cs{@starttoc} 引入的其他类似列表）中，我们抑制索引。
% 这是因为标题中出现的 \cs{cmd}、\cs{cs} 或 \cs{tn} 只会在第二次运行时排版，
% 并且正确地对其进行索引需要比我们已经需要的运行次数更多。
% 此外，在目录中索引某些命令的用法并不实用。
%    \begin{macrocode}
\bool_new:N \l_@@_allow_indexing_bool
\bool_set_true:N \l_@@_allow_indexing_bool
\use:e
  {
    \exp_not:n { \cs_set_nopar:Npn \@starttoc #1 }
      {
        \group_begin:
          \bool_set_false:N \l_@@_allow_indexing_bool
          \exp_not:o { \@starttoc {#1} }
        \group_end:
      }
  }
%    \end{macrocode}
%
% \subsubsection{用户空间命令}
%
% 修复索引（暂时）：
%    \begin{macrocode}
\g@addto@macro \theindex { \MakePrivateLetters }
\cs_gset:Npn \verbatimchar {&}
%    \end{macrocode}
%
%    \begin{macrocode}
\setcounter { IndexColumns } { 2 }
%    \end{macrocode}
%
% 设置索引使用 \tn{part}
%    \begin{macrocode}
\IndexPrologue
  {
    \part*{Index}
    \markboth{Index}{Index}
    \addcontentsline{toc}{part}{Index}
    The~italic~numbers~denote~the~pages~where~the~
    corresponding~entry~is~described,~
    numbers~underlined~point~to~the~definition,~
    all~others~indicate~the~places~where~it~is~used.
  }
%    \end{macrocode}
%
% \begin{macro}{\SpecialIndex}
% 尝试影响出现在 \env{macrocode} 环境中的命令在索引中的处理方式。
%    \begin{macrocode}
\cs_gset_protected:Npn \SpecialIndex #1
  {
    \@bsphack
    \@@_special_index:nn {#1} { }
    \@esphack
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\msg_new:nnn { l3doc } { print-index-howto }
  {
    Generate~the~index~by~executing\\
    \iow_indent:n
      { makeindex~-s~gind.ist~-o~\c_sys_jobname_str.ind~\c_sys_jobname_str.idx }
  }
\tl_gput_right:Nn \PrintIndex
  { \AtEndDocument { \msg_info:nn { l3doc } { print-index-howto } } }
%    \end{macrocode}
%
% \subsubsection{内部索引命令}
%
% \begin{macro}{\it@is@a}
%   在 \env{macrocode} 环境中，一字符命令的索引是通过 \tn{it@is@a} \meta{char} 来生成的。可以修改该命令。
%    \begin{macrocode}
\cs_gset_protected:Npn \it@is@a #1
  {
    \use:e
      {
        \@@_special_index_module:nnnnN
          {#1}
          { \bslash #1 }
          { }
          { }
          \c_false_bool
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_special_index:nn}
% ^^A TODO this override is somewhat a hack
%    \begin{macrocode}
\cs_new_protected:Npn \@@_special_index:nn #1#2
  {
    \@@_key_get:n {#1}
    \quark_if_no_value:NF \l_@@_override_module_tl
      { \tl_set_eq:NN \l_@@_index_module_tl \l_@@_override_module_tl }
    \@@_special_index_module:ooonN
      { \l_@@_index_key_tl }
      { \l_@@_index_macro_tl }
      { \l_@@_index_module_tl }
      {#2}
      \l_@@_index_internal_bool
  }
\cs_generate_variant:Nn \@@_special_index:nn { o }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_special_index_module:nnnnN,
%     \@@_special_index_module:ooonN,
%     \@@_special_index_aux:nnnnnn,
%     \@@_special_index_set:Nn,
%   }
%   远程基于 Heiko 的替换方法，可以与 \pkg{hypdoc} 友好地配合使用。我们使用 
%   \tn{verb} 或 \tn{verbatim@font} 结构，这取决于 |#2| 中的令牌数是否等于
%   其字符数：如果不等，则表明存在诸如 |\meta{...}| 这样的结构。
%    \begin{macrocode}
\tl_new:N \l_@@_index_escaped_macro_tl
\tl_new:N \l_@@_index_escaped_key_tl
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_special_index_module:nnnnN #1#2#3#4#5
%    \end{macrocode}
% \begin{arguments}
% \item key
% \item macro
% \item module
% \item 索引“类型”（\texttt{main}/\texttt{usage}/\emph{等等}）
% \item 是否是内部命令的布尔值
% \end{arguments}
%    \begin{macrocode}
  {
    \use:e
      {
        \exp_not:n { \@@_special_index_aux:nnnnnn {#1} {#2} }
          \tl_if_empty:nTF {#3}
            { { } { } { } }
            {
              \str_if_eq:nnTF {#3} { TeX }
                {
                  { TeX~and~LaTeX2e }
                  { \string\TeX{}~and~\string\LaTeXe{} }
                }
                {
                  {#3}
                  { \string\pkg{#3} }
                }
              { \bool_if:NT #5 { ~internal } ~commands: }
            }
      }
          {#4}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_generate_variant:Nn \@@_special_index_module:nnnnN { ooo }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_special_index_aux:nnnnnn #1#2#3#4#5#6
%    \end{macrocode}
% \begin{arguments}
% \item key
% \item macro
% \item 索引子标题字符串
% \item 索引子标题文本
% \item 索引子标题后缀（附加到参数 3 和 4）
% \item 索引“类型”（\texttt{main}/\texttt{usage}/\emph{等等}）
% \end{arguments}
%    \begin{macrocode}
  {
    \tl_set:Nn \l_@@_index_escaped_key_tl {#1}
    \@@_quote_special_char:N \l_@@_index_escaped_key_tl
    \@@_special_index_set:Nn \l_@@_index_escaped_macro_tl {#2}
    \str_if_eq:onTF { \@currenvir } { macrocode }
      { \@@_index_codeline_hc:nn }
      {
        \str_case:nnF {#6}
          {
            { main }  { \@@_index_codeline_hc:nn }
            { usage } { \@@_index_page_hc:nn }
          }
          { \@@_target: \@@_index_page_hc:nn }
      }
      {
        \tl_if_empty:nF { #3 #4 #5 }
          { #3 #5 \actualchar #4 #5 \levelchar }
        \l_@@_index_escaped_key_tl
        \actualchar
        {
          \token_to_str:N \verbatim@font \c_space_tl
          \l_@@_index_escaped_macro_tl
        }
      }
      {#6}
  }
%    \end{macrocode}
%
% \begin{macro}{\hdpindex, \@@_old_hdpindex:nn, \hdclindex, \@@_old_hdclindex:nnn, \@@_hdindex:nn, \c_@@_active_minus_tl, \@@_hdindex_aux:nn, \@@_hdindex_aux:w}
%   注意，如果几个连续的代码行以某种方式合并成一个范围，则 |#3| 可能会包含 |MMMMI-| 或 |MMMMV-| 多次。
%   顺便提一下，破折号在我们的某些源文件中是活跃的，比如 |interface3.tex| 或 |source2e.tex|。
%    \begin{macrocode}
\group_begin:
\char_set_active_eq:NN - \scan_stop:
\tl_const:Ne \c_@@_active_minus_tl { \char_generate:nn { `- } { 13 } }
\group_end:
\cs_new_eq:NN \@@_old_hdpindex:nn \hdpindex
\cs_new_eq:NN \@@_old_hdclindex:nnn \hdclindex
\cs_gset_protected:Npn \hdpindex #1
  { \@@_hdindex:nn { \@@_old_hdpindex:nn {#1} } }
\cs_gset_protected:Npn \hdclindex #1#2
  { \@@_hdindex:nn { \@@_old_hdclindex:nnn {#1} {#2} } }
\cs_new_protected:Npn \@@_hdindex:nn #1#2
  {
    \tl_set:Nn \l_@@_tmpa_tl {#2}
    \tl_replace_all:Nen \l_@@_tmpa_tl
      { \exp_not:V \c_@@_active_minus_tl \exp_not:V \c_@@_active_minus_tl }
      { -- }
    \seq_set_split:NnV \l_@@_tmpa_seq { -- } \l_@@_tmpa_tl
    \seq_set_map:NNn \l_@@_tmpa_seq \l_@@_tmpa_seq
      { \@@_hdindex_aux:nn {#1} {##1} }
    \seq_use:Nn \l_@@_tmpa_seq { -- }
  }
\cs_new_protected:Npn \@@_hdindex_aux:nn #1#2
  {
    \tl_set:Nn \l_@@_tmpa_tl {#2}
    \tl_replace_all:Nnn \l_@@_tmpa_tl { MMMM } { \use_none:nn }
    \tl_if_in:NnT \l_@@_tmpa_tl { MMMD }
      {
        \tl_replace_all:Nen \l_@@_tmpa_tl
          { \exp_not:V \c_@@_active_minus_tl MMMD } { - MMMD }
        \tl_replace_all:Nnn \l_@@_tmpa_tl { - MMMD } { \@@_hdindex_aux:w }
      }
    \use:e { \exp_not:n {#1} { \exp_not:V \l_@@_tmpa_tl } }
  }
\cs_new_protected:Npn \@@_hdindex_aux:w #1 M { }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_special_index_set:Nn #1#2
  {
    \__kernel_tl_set:Ne #1 { \tl_to_str:n {#2} }
    \@@_if_almost_str:nTF {#2}
      {
        \tl_replace_all:Nen #1 { \tl_to_str:n { __ } }
          {
            \verbatimchar
            \token_to_str:N \_ \token_to_str:N \_
            \token_to_str:N \verb * \verbatimchar
          }
        \exp_args:Ne \tl_map_inline:nn
          { \tl_to_str:N \verbatimchar \token_to_str:N _ }
          {
            \tl_replace_all:Nnn #1 {##1}
              {
                \verbatimchar \c_backslash_str ##1
                \token_to_str:N \verb * \verbatimchar
              }
          }
        \__kernel_tl_set:Ne #1
          {
            \token_to_str:N \verb * \verbatimchar
            #1 \verbatimchar
          }
      }
      {
        \tl_set:Nn #1 {#2}
        \tl_replace_all:NVn #1
          \c_backslash_str
          { \token_to_str:N \bslash \c_space_tl }
      }
    \@@_quote_special_char:N #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_quote_special_char:N}
% 引用一些特殊字符。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_quote_special_char:N #1
  {
    \tl_map_inline:nn { \quotechar \actualchar \encapchar \levelchar \bslash }
      {
        \tl_replace_all:Nen #1
          { \tl_to_str:N ##1 } { \quotechar \tl_to_str:N ##1 }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{查找排序键和模块}
%
% \begin{macro}{\@@_key_get:n}
% 从 |#1| 设置 \cs{l_@@_index_macro_tl}、\cs{l_@@_index_key_tl} 和 \cs{l_@@_index_module_tl}。
% 基本函数由 \cs{@@_key_get_base:nN} 存储在 \cs{l_@@_index_macro_tl} 中，如果包含标记或没有签名，则回退到 |#1|。
%
% \meta{key} 的起始点是字符串 \cs{l_@@_index_key_tl}。
% 如果第一个字符是反斜杠，则删除它。然后通过存在 |:| 或~|_| 的方式识别 |expl| 函数和变量，通过存在 |@| 的方式识别 \TeX{}/\LaTeXe{} 命令。
% 对于 |expl| 名称，我们调用 \cs{@@_key_func:} 或 \cs{@@_key_var:}，负责删除一些字符并找到模块名称，而对于 \TeX{}/\LaTeXe{} 命令，模块名称是 |TeX|，其他命令的模块名称为空。
%    \begin{macrocode}
\cs_new_protected:Npe \@@_key_get:n #1
  {
    \exp_not:N \@@_key_get_base:nN {#1} \exp_not:N \l_@@_index_macro_tl
    \__kernel_tl_set:Ne \exp_not:N \l_@@_index_key_tl
      { \exp_not:N \tl_to_str:N \exp_not:N \l_@@_index_macro_tl }
    \tl_clear:N \exp_not:N \l_@@_index_module_tl
    \tl_if_in:NnTF \exp_not:N \l_@@_index_key_tl { \tl_to_str:n { __ } }
      { \bool_set_true:N \exp_not:N \l_@@_index_internal_bool }
      { \bool_set_false:N \exp_not:N \l_@@_index_internal_bool }
    \exp_not:N \tl_if_head_eq_charcode:VNT
      \exp_not:N \l_@@_index_key_tl \c_backslash_str
      { \exp_not:N \@@_key_pop: }
    \tl_if_in:NnTF \exp_not:N \l_@@_index_key_tl { \token_to_str:N : }
      { \exp_not:N \@@_key_func: }
      {
        \tl_if_in:NnTF \exp_not:N \l_@@_index_key_tl { \token_to_str:N _ }
          { \exp_not:N \@@_key_var: }
          {
            \tl_if_in:NnT \exp_not:N \l_@@_index_key_tl { \token_to_str:N @ }
              { \tl_set:Nn \exp_not:N \l_@@_index_module_tl { TeX } }
          }
      }
  }
\cs_new_protected:Npn \@@_key_pop:
  {
    \__kernel_tl_set:Ne \l_@@_index_key_tl
      { \tl_tail:N \l_@@_index_key_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_key_trim_module:n, \@@_key_drop_underscores:}
% 辅助函数，从 \cs{l_@@_index_module_tl} 中删除第一次出现 |#1| 之后的所有内容。
% 辅助函数，删除 \cs{l_@@_index_key_tl} 的任何前导下划线。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_key_trim_module:n #1
  {
    \cs_set:Npn \@@_tmpa:w ##1 #1 ##2 \q_stop
      { \exp_not:n {##1} }
    \__kernel_tl_set:Ne \l_@@_index_module_tl
      { \exp_after:wN \@@_tmpa:w \l_@@_index_module_tl #1 \q_stop }
  }
\cs_new_protected:Npn \@@_key_drop_underscores:
  {
    \tl_if_head_eq_charcode:VNT \l_@@_index_key_tl _
      { \@@_key_pop: \@@_key_drop_underscores: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_key_func:}
%   函数 \cs{@@_key_func:} 用于处理带有冒号的情况，通常用于 \pkg{expl3} 函数或者来自 \pkg{l3keys} 的键。
%   在处理键时，会移除前导的句点（对于后一种情况），以及任何前导下划线，模块名称即是在冒号或下划线之前的部分。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_key_func:
  {
    \tl_if_head_eq_charcode:VNT \l_@@_index_key_tl .
      { \@@_key_pop: }
    \@@_key_drop_underscores:
    \tl_set_eq:NN \l_@@_index_module_tl \l_@@_index_key_tl
    \exp_args:No \@@_key_trim_module:n { \token_to_str:N : }
    \exp_args:No \@@_key_trim_module:n { \token_to_str:N _ }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_key_var:, \@@_key_get_module:}
%   函数 \cs{@@_key_var:} 处理没有 |:| 但有 |_| 的情况，通常是变量，偶尔是带有下划线的非 \pkg{expl3} 函数（比如 Lua 函数）。
%   首先检测第二个字符：如果是 |_|，则认为是正确的变量；否则将下划线之前的部分作为模块名称。
%   对于变量，区分 quarks 和 scan marks（以 |q| 和 |s| 开头），然后去掉第一个字母（局部/全局/常量标记）和下划线，以改善索引排序。
%   然后获取模块作为第一个（以下划线分隔的）“单词”。
%   以前我们根据有多少这样的“单词”来区分，以便检测诸如 \cs[no-index]{c_zero} 这样的命令，它应该按照 |int| 变量排序，
%   以及 \cs[no-index]{l_tmpa_dim}，它应该在 |dim| 而不是 |tmpa| 模块中排序。
%   现在第一种情况已经被弃用了一段时间，而 |tmpa| 和类似的情况是通过下面显式列表特殊处理的。
%   工作原理是，如果模块在一个非有效模块名称的列表中，那么我们尝试最后一个词，如果也失败了（比如在弃用的 \cs[no-index]{c_one_hundred} 中），
%   我们就完全清空模块。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_key_var:
  {
    \exp_args:Ne \tl_if_head_eq_charcode:nNTF
      { \exp_args:No \str_tail:n \l_@@_index_key_tl } _
      {
        \str_case:en { \str_head:N \l_@@_index_key_tl }
          {
            { q } { \tl_set:Nn \l_@@_index_module_tl { quark } }
            { s } { \tl_set:Nn \l_@@_index_module_tl { scan } }
          }
        \@@_key_pop:
        \@@_key_pop:
        \@@_key_drop_underscores:
        \tl_if_empty:NT \l_@@_index_module_tl
          {
            \seq_set_split:NoV \l_@@_tmpa_seq
              { \token_to_str:N _ } \l_@@_index_key_tl
            \seq_get_left:NN \l_@@_tmpa_seq \l_@@_index_module_tl
            \clist_if_in:NoT \g_@@_non_modules_clist \l_@@_index_module_tl
              {
                \seq_get_right:NN \l_@@_tmpa_seq \l_@@_index_module_tl
                \clist_if_in:NoT \g_@@_non_modules_clist \l_@@_index_module_tl
                  {
                    \tl_clear:N \l_@@_index_module_tl
                  }
              }
          }
      }
      {
        \tl_set_eq:NN \l_@@_index_module_tl \l_@@_index_key_tl
        \exp_args:No \@@_key_trim_module:n { \token_to_str:N _ }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\g_@@_non_modules_clist}
%   包含在 \pkg{expl3} 命令中出现的第一个单词列表，但它们不是真正的模块，因此在索引中应该按不同方式排序。
%    \begin{macrocode}
\clist_new:N \g_@@_non_modules_clist
\clist_gset:Ne \g_@@_non_modules_clist
  {
    \tl_to_str:n
      {

        alignment, ampersand, atsign, backslash, catcode, circumflex,
        code, colon, document, dollar, e, empty, false, hash, inf,
        initex, job, left, log, math, mark, max, minus, nan, nil, no,
        novalue, other, parameter, percent, pi, recursion, right, space,
        stop, term, tilde, tmpa, tmpb, true, underscore, zero, one, two,
        three, four, five, six, seven, eight, nine, ten, eleven, twelve,
        thirteen, fourteen, fifteen, sixteen, thirty, hundred

      }
  }
%    \end{macrocode}
% \end{variable}
%
% \subsection{历次更新}
%
% 将变更历史设置为使用 \tn{part}。
% 允许在此处将控制命令连字符化\dots
%    \begin{macrocode}
\GlossaryPrologue
  {
    \part*{Change~History}
    {\GlossaryParms\ttfamily\hyphenchar\font=`\-}
    \markboth{Change~History}{Change~History}
    \addcontentsline{toc}{part}{Change~History}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { l3doc } { print-changes-howto }
  {
    Generate~the~change~list~by~executing\\
    \iow_indent:n
      { makeindex~-s~gglo.ist~-o~\c_sys_jobname_str.gls~\c_sys_jobname_str.glo }
  }
\tl_gput_right:Nn \PrintChanges
  { \AtEndDocument { \msg_info:nn { l3doc } { print-changes-howto } } }
%    \end{macrocode}
%
%^^A The standard \changes command modified slightly to better cope with
%^^A this multiple file document.
%^^A\def\changes@#1#2#3{%
%^^A  \let\protect\@unexpandable@protect
%^^A  \edef\@tempa{\noexpand\glossary{#2\space\currentfile\space#1\levelchar
%^^A                                 \ifx\saved@macroname\@empty
%^^A                                   \space
%^^A                                   \actualchar
%^^A                                   \generalname
%^^A                                 \else
%^^A                                   \expandafter\@gobble
%^^A                                   \saved@macroname
%^^A                                   \actualchar
%^^A                                   \string\verb\quotechar*%
%^^A                                   \verbatimchar\saved@macroname
%^^A                                   \verbatimchar
%^^A                                 \fi
%^^A                                 :\levelchar #3}}%
%^^A  \@tempa\endgroup\@esphack}
%
% \subsection{默认配置}
%
%    \begin{macrocode}
\bool_if:NTF \g_@@_typeset_implementation_bool
  {
    \RecordChanges
    \CodelineIndex
    \EnableCrossrefs
    \AlsoImplementation
  }
  {
    \CodelineNumbered
    \DisableCrossrefs
    \OnlyDescription
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</class>
%    \end{macrocode}
%
% \subsection{\LaTeX3 源文件的内部宏}
%
% 这些定义仅供 \LaTeX3 文档使用；对于 \cls{l3doc} 的第三方用户来说并非必需。以后这将被拆分成一个专门在各种 \pkg{expl3} 模块中加载的单独包。
%
%    \begin{macrocode}
%<*cfg>
%    \end{macrocode}
%
% 负责人。
%    \begin{macrocode}
\tl_const:Nn \Team
  {
    The~\LaTeX3~Project\thanks
      {\url{https://www.latex-project.org/latex3/}}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\NewDocumentCommand{\ExplMakeTitle}{mm}
  {
    \title
      {
       The~\pkg{#1}~package \\ #2
      }
    \author
      {
       The~\LaTeX3~Project\thanks{E-mail:~
       \href{mailto:latex-l@listserv.uni-heidelberg.de}
            {latex-l@listserv.uni-heidelberg.de}}
      }
    \date{Released~\ExplFileDate}
    \maketitle
  }
%    \end{macrocode}
%
% \subsection{数学扩展}
%
% 用于 \pkg{l3fp}。
%
%    \begin{macrocode}
\AtBeginDocument
  {
    \clist_map_inline:nn
      {
       asin, acos, atan, acot,
       asinh, acosh, atanh, acoth, round, floor, ceil
      }
      { \exp_args:Nc \DeclareMathOperator{#1}{#1} }
  }
%    \end{macrocode}
%
% \begin{macro}{\nan}
%    \begin{macrocode}
\NewDocumentCommand { \nan } { } { \text { \texttt { nan } } }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</cfg>
%    \end{macrocode}
%
%
% \subsection{Makeindex 配置}
%
%    \begin{macrocode}
%<*docist>
%    \end{macrocode}
%
% 用 \file{l3doc.ist} 样式文件代替通常的 \file{gind.ist}，以确保在序列 |I J K| 中使用 |I| 而不是默认的 makeindex 行为 |I II III|。
%
% Will: 我们需要这个吗？
%
% Frank: 目前我们不分发或生成此文件。我们使用 \file{gind.ist}。
%
% \begin{macro}[do-not-index={\\,\n}]{}
%    \begin{macrocode}
actual '='
quote '!'
level '>'
preamble
"\n \\begin{theindex} \n \\makeatletter\\scan@allowedfalse\n"
postamble
"\n\n \\end{theindex}\n"
item_x1   "\\efill \n \\subitem "
item_x2   "\\efill \n \\subsubitem "
delim_0   "\\pfill "
delim_1   "\\pfill "
delim_2   "\\pfill "
% The next lines will produce some warnings when
% running Makeindex as they try to cover two different
% versions of the program:
lethead_prefix   "{\\bfseries\\hfil "
lethead_suffix   "\\hfil}\\nopagebreak\n"
lethead_flag       1
heading_prefix   "{\\bfseries\\hfil "
heading_suffix   "\\hfil}\\nopagebreak\n"
headings_flag       1

% and just for source3:
% Remove R so I is treated in sequence I J K not I II III
page_precedence "rnaA"
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</docist>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
