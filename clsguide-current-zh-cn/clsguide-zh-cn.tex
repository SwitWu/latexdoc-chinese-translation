% !TEX program = xelatex
% \iffalse meta-comment
%
% Copyright (C) 2023
% The LaTeX Project and any individual authors listed elsewhere
% in this file.
%
% This file is part of the LaTeX base system.
% -------------------------------------------
%
% It may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3c
% of this license or (at your option) any later version.
% The latest version of this license is in
%    http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2008 or later.
%
% This file has the LPPL maintenance status "maintained".
%
% The list of all files belonging to the LaTeX base distribution is
% given in the file `manifest.txt'. See also `legal.txt' for additional
% information.
%
% The list of derived (unpacked) files belonging to the distribution
% and covered by LPPL is defined by the unpacking scripts (with
% extension .ins) which are part of the distribution.
%
% \fi
% Filename: clsguide.tex

\PassOptionsToPackage{quiet}{fontspec}
\documentclass{ltxguide}

\usepackage[T1]{fontenc}  % needed for \textbackslash in tt
\usepackage{csquotes}

%% ============================= 中文版设置 ================================
\usepackage{xeCJK}  %%
%%%%%%%%%%%%%%% 思源字体 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setCJKmainfont {SourceHanSerifSC}
[
  Extension   = .otf,
  UprightFont = *-regular,
  BoldFont    = *-Bold,
  ItalicFont  = FandolKai-Regular
]
\setCJKsansfont {SourceHanSansSC}
[
  Extension   = .otf,
  UprightFont = *-regular,
  BoldFont    = *-Bold
]
\setCJKmonofont {FandolKai}
[
  Extension   = .otf,
  UprightFont = *-regular
]
\newCJKfontfamily[song]\songti{SourceHanSerifSC-regular.otf} %%自定义宋体 \sognti ，作为文章中文主字体
\newCJKfontfamily[hei]\heiti{SourceHanSansSC-regular.otf} %%自定义黑体 \heiti ，在幻灯片中黑体(SimHei)最漂亮
\newCJKfontfamily[kai]\kaiti{FandolKai-regular.otf} %%设置中文字体楷体 \kaiti ，用于强调
%%%%%%%%%%%%%%%%%%%% Windows系统自带字体 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \newCJKfontfamily[song]\songti{SimSun} %%自定义黑体 \heiti ，在幻灯片中黑体(SimHei)最漂亮
% \newCJKfontfamily[hei]\heiti{SimHei} %%自定义宋体 \sognti ，作为文章中文主字体
% \newCJKfontfamily[kai]\kaiti{KaiTi} %%设置中文字体楷体 \kaiti ，用于强调
% \setCJKmainfont{SimSun}[BoldFont = SimHei] %%设置主中文字体为宋体
% \setCJKsansfont{SimHei} %%设置中文无衬线字体为黑体
% \setCJKmonofont{KaiTi} %%设置中文等宽字体为楷体（主要影响\ttfamily和\texttt{}）
%%%%%%%%%%%%%%% Fandol字体 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \newCJKfontfamily[song]\songti{FandolSong-Regular.otf} %%自定义黑体 \heiti ，在幻灯片中黑体(SimHei)最漂亮
% \newCJKfontfamily[hei]\heiti{FandolHei-Regular.otf} %%自定义宋体 \sognti ，作为文章中文主字体
% \newCJKfontfamily[kai]\kaiti{FandolKai-Regular.otf} %%设置中文字体楷体 \kaiti ，用于强调
% \setCJKmainfont{FandolSong-Regular.otf}[BoldFont = FandolSong-Bold.otf] %%设置主中文字体为宋体
% \setCJKsansfont{FandolHei-Regular.otf}[BoldFont = FandolHei-Bold.otf] %%设置中文无衬线字体为黑体
% \setCJKmonofont{FandolKai-Regular.otf} %%设置中文等宽字体为楷体（主要影响\ttfamily和\texttt{}）
%%%%%%%%%%%%% 以上设置中文字体 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%% 以下设置中文版式 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{indentfirst} %%% 首行缩进
\setlength{\parindent}{2em} %%% 缩进2个字符（中文为2个字）
\linespread{1.242} %%% 设置行间距
\renewcommand{\contentsname}{\centerline{目\quad 录}}   %%% 在{document}后面加入该命令，将"contents"变成“目  录”
\renewcommand{\refname}{参考文献}
\renewcommand{\tablename}{表}
\NewDocumentCommand{\booktitle}{ m }{《\bgroup\color{blue}\sffamily#1\egroup》}
\catcode`《 = \active
\def《#1》{\booktitle{#1}}
%%%%%%%%%%%%% 以上设置中文版式 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%% 以下设置书签、目录 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{xcolor}
\usepackage{hyperref}
\definecolor{spot}{HTML}{003399}
\definecolor{code}{HTML}{a25e26}
\definecolor{verb}{HTML}{007f00}
\AtBeginEnvironment{decl}{\color{spot}}
\patchcmd{\NEWfeature}{New feature}{\kaiti\color{spot}新的特色}{}{}
\patchcmd{\NEWdescription}{New description}{\kaiti\color{spot}新的说明}{}{}
\AtBeginEnvironment{verbatim}{\color{verb}}
\AtBeginEnvironment{alltt}{\color{verb}}
\hypersetup{%
  colorlinks=true,
  linkcolor=spot,
  urlcolor=spot,
  citecolor=spot,
  bookmarksopen=false,
  bookmarksnumbered=false,
  plainpages=false,
  pdfview=FitH}
%%%%%%%%%%%% 以上设置书签、目录 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ========================================================================

\title{\color{spot}\huge\bfseries 面向宏包与类文件编写者\\[3pt]的\ \LaTeX\Large\ ——当前版本}
\author{\copyright~Copyright 2023, \LaTeX\ Project Team.\\
   版权所有%
   \footnote{本文件可以在\LaTeX{}项目公共许可证 ( the \LaTeX{} Project Public License, 即 LPPL v1.3c ) 的条件下进行分发和/或修改，可以选择遵循
   本许可证的1.3c版本或者（根据您的选择）任何以后的版本。请参阅源文件
   \texttt{clsguide.tex} 获取完整的详细信息。}%
   \\[6pt]
   张泓知\qquad 翻译
}

\date{2023年10月24日}

\NewDocumentCommand\cs{m}{\texttt{\textbackslash\detokenize{#1}}}
\NewDocumentCommand\marg{m}{\arg{#1}}
\NewDocumentCommand\meta{m}{\ensuremath{\langle}\textit{#1}\ensuremath{\rangle}}
\NewDocumentCommand\pkg{m}{\textsf{#1}}
\NewDocumentCommand\text{m}{\ifmmode\mbox{#1}\else#1\fi}
% Fix a 'feature'
\makeatletter
\renewcommand \verbatim@font {\normalfont \ttfamily}
\makeatother
\providecommand\url[1]{\texttt{#1}}

\begin{document}

\maketitle

\pdfbookmark[1]{目录}{Contents}
\tableofcontents

\section{介绍}

\LaTeXe{}于1994年发布，为\LaTeX{}引入了一些新概念。这些概念在
\texttt{clsguide-historic}中为宏包和类的作者进行了描述，该文档在很大程度
上保持不变。此后，\LaTeX{}团队致力于多个想法：首先是为\LaTeX{}设计的编程
语言（L3编程层），然后是一系列建立在该语言基础上的作者工具。在这里，我们
概述了由\LaTeX{}核心提供给宏包和类开发者的当前稳定工具集。我们假设读者作
为文档作者熟悉一般的\LaTeX{}用法，并建议阅读本文与\texttt{usrguide}结合，
后者提供给一般\LaTeX{}用户有关创建命令等当代方法的信息。

\section{编写类和宏包}
\label{Sec:writing}

本节讨论了编写\LaTeX{}类和宏包的基本要点。

\subsection{是类还是宏包？}
\label{Sec:classorpkg}

当您想在文件中添加一些新的 \LaTeX{} 命令时，首先要决定它是一个\emph{文档类}还是一个\emph{宏包}。
经验法则是：
\begin{quote}
   如果这些命令可以与任何文档类一起使用，那么将它们制作为一个宏包；否则，将其制作为一个类。
\end{quote}

类有两种主要类型：像 |article|、|report| 或 |letter| 这样的独立类；以及扩展或变体其他类的类，比如
构建在 |article| 文档类之上的 |proc| 文档类。

因此，一个公司可能会有一个用于打印带有自己抬头纸的信件的本地 |ownlet| 类。这样的类将在现有的 |letter|
类的基础上构建，但它不能与其他任何文档类一起使用，因此我们有了 |ownlet.cls| 而不是 |ownlet.sty|。

相比之下，|graphics| 宏包提供了将图像包含到 \LaTeX{} 文档中的命令。由于这些命令可以与任何文档类
一起使用，我们有了 |graphics.sty| 而不是 |graphics.cls|。

\subsection{使用 `docstrip' 和 `doc'}

如果您打算为 \LaTeX{} 编写一个大型的文档类或宏包，您应该考虑使用
随 \LaTeX{} 一起提供的 |doc| 软件。
使用 |doc| 编写的 \LaTeX{} 文档类和宏包可以以两种方式进行处理：
它们可以通过 \LaTeX{} 运行以生成文档；也可以通过 |docstrip| 运行以生成
|.cls| 或 |.sty| 文件。

|doc| 软件可以自动生成定义索引、命令使用索引和变更记录列表。它对于维护和
记录大型 \TeX{} 源文件非常有用。

\LaTeX{} 核心本身以及标准文档类等的文档化源代码都是 |doc| 文档；它们位于
分发中的 |.dtx| 文件中。实际上，您可以通过在 |source2e.tex| 上运行
\LaTeX{} 来排版核心源代码作为一个长文档，包括索引。排版这些文档使用了
类文件 |ltxdoc.cls|。

有关 |doc| 和 |docstrip| 的更多信息，请参阅文件 |docstrip.dtx|、|doc.dtx|
和 《\LaTeXcomp》。要了解其用法示例，请查看 |.dtx| 文件。

\subsection{标准文档类的政策}

我们收到的有关标准文档类的问题报告中，很多并不涉及错误，而是更或
多或少地礼貌地暗示这些类中体现的设计决策“不够优秀”，并要求我们
对其进行修改。

有几个原因我们不应该对这些文件进行此类更改：
\begin{itemize}
   \item
         不管多么误导，当前的行为显然是设计这些类时所预期的。
   \item
         更改“标准类”的这些方面并不是一个好的做法，因为许多人将依赖
         于它们。
\end{itemize}

因此，我们决定甚至不考虑进行这种修改，也不花时间来证明这个决定。
这并不意味着我们不同意这些类的设计存在许多缺陷，但是我们有许多更
重要的任务，而不是不断解释为什么 \LaTeX{} 的标准文档类不能改变。

当然，我们欢迎更好的类的产生，或者用于增强这些类的包的出现。因此，
当您考虑到这样的不足时，我们希望您首先的想法是“我能做些什么来改
善这个？”

\subsection{命令名称}

在介绍下一节中描述的 L3 编程层引入之前，\LaTeX{} 有三种类型的命令。

第一种是作者命令，比如 |\section|、|\emph| 和 |\times|：这些命令
通常有简短的名称，全部是小写。

第二种是类和宏包编写者命令：
这些命令通常有长的混合大小写名称，例如以下几个。
\begin{verbatim}
   \InputIfFileExists  \RequirePackage  \PassOptionsToClass
\end{verbatim}

最后一种是用于 \LaTeX{} 实现的内部命令，比如 |\@tempcnta|、|\@ifnextchar| 和
|\@eha|：其中大多数命令的名称中包含 |@|，这意味着它们不能在文档中使用，
只能在类和宏包文件中使用。

不幸的是，出于历史原因，这些命令之间的区别通常很模糊。例如，|\hbox| 是
一个内部命令，只应在 \LaTeX{} 核心中使用，而 |\m@ne| 是常数 $-1$，本来
可以命名为 |\MinusOne|。

然而，这个经验法则仍然有用：如果一个命令的名称中包含 |@|，那么它不是
支持的 \LaTeX{} 语言的一部分——它的行为可能在未来版本中改变！如果一个
命令是混合大小写的，或者在 《\LaTeXbook》 中有描述，那么您可以依赖
于未来版本的 \LaTeX{} 支持该命令。

\subsection{编程支持}

正如在介绍中所指出的，\LaTeX{} 核心今天加载了来自编程的专用支持，这里
称为 L3 编程层，通常也称为 \pkg{expl3}。L3 编程层的一般方法的详细信息
在文档 \texttt{expl3} 中给出，而当前所有代码接口的参考可以在
\texttt{interface3} 中找到。这个层包含两种类型的命令：一个由 API 组成的
文档化命令集，和大量的私有内部命令。后者都以两个下划线开头，不应在定义
它们的代码模块之外使用。这种更有结构的方法意味着使用 L3 编程层不会像使用
`\texttt{@} 命令' 那样受到上面提到的某种程度上的不稳定情况的影响。

在这里我们不涉及使用 L3 编程层的细节。关于该方法的良好介绍可在
\url{https://www.alanshawn.com/latex3-tutorial/} 找到。

\subsection{盒子命令和颜色}
\label{Sec:color}

即使您不打算在自己的文档中使用颜色，通过注意本节中的要点，您可以确保您的
文档类或宏包与 |color| 宏包兼容。这可能有利于使用您的文档类或宏包并希望
使用颜色的人。

确保“颜色安全”的最简单方法是始终使用 \LaTeX{} 的盒子命令而不是 \TeX{}
的原始命令，即使用 |\sbox| 而不是 |\setbox|，|\mbox| 而不是 |\hbox|，
|\parbox| 或 |minipage| 环境而不是 |\vbox|。现在，\LaTeX{} 的盒子命令具
有新的选项，使其与 \TeX{} 的原始命令一样强大。

举例说明可能出现的问题，考虑 |{\ttfamily <text>}| 中字体恢复的时间点在
最后的 |}| \emph{之前}，而在类似的结构 |{\color{green} <text>}| 中颜色
恢复的时间点在最后的 |}| \emph{之后}。通常，这种区别并不重要；但是考虑一
个类似于原始 \TeX{} 盒子赋值的命令，比如：
\begin{verbatim}
   \setbox0=\hbox{\color{green} <text>}
\end{verbatim}
现在，颜色恢复在 |}| 之后发生，因此\emph{不会}存储在盒子中。这可能会
产生的坏影响取决于颜色的实现方式：从文档其余部分出现错误的颜色到导致用
于打印文档的 dvi 驱动程序出现错误。

另一个有趣的命令是 |\normalcolor|。通常它只是 |\relax|（即什么也不做），
但您可以像使用 |\normalfont| 那样将其用于设置页面上的区域，比如标题或节
标题的“主文档颜色”。

\subsection{通用风格}
\label{Sec:general}

\LaTeX{} 提供了许多命令，旨在帮助您生成结构良好、健壮且可移植的文档类
和宏包文件。本节概述了一些使用这些命令的智能方式。

\subsubsection{加载其他文件}
\label{Sec:loading}

\LaTeX{} 提供了以下命令：
\begin{verbatim}
   \LoadClass        \LoadClassWithOptions
   \RequirePackage   \RequirePackageWithOptions
\end{verbatim}
用于在其他文档类或宏包中使用类或宏包。我们强烈建议您使用这些命令，而不是
原始的 |\input| 命令，原因有几个。

使用 |\input <filename>| 加载的文件不会列在 |\listfiles| 列表中。

如果一个宏包始终使用 |\RequirePackage...| 或 |\usepackage| 加载，
即使请求多次加载，它也只会被加载一次。相比之下，如果使用 |\input| 加载，
则可以加载多次；多余的加载可能会浪费时间和内存，并且可能会产生奇怪的结果。

如果一个宏包提供选项处理，那么如果不是使用 |\usepackage| 或 |\RequirePackage...|
加载，而是使用 |\input|，则可能会产生奇怪的结果。

如果宏包 |foo.sty| 使用 |\input baz.sty| 加载了宏包 |baz.sty|，则用户会得到警告：
\begin{verbatim}
   LaTeX Warning: You have requested package `foo',
                  but the package provides `baz'.
\end{verbatim}
因此，由于几个原因，使用 |\input| 加载宏包并不是一个好主意。

例如，|article.sty| 只包含以下几行：
\begin{verbatim}
   \NeedsTeXFormat{LaTeX2e}
   \@obsoletefile{article.cls}{article.sty}
   \LoadClass{article}
\end{verbatim}
您可能希望做相同的事情，或者如果认为安全的话，可以决定移除 |myclass.sty|。

\subsubsection{使它健壮}

在编写宏包和文档类时，我们认为尽可能使用 \LaTeX{} 命令是一种良好的做法。

因此，我们建议在编程和定义文档接口时，使用 |\newcommand|、|\renewcommand|
或 |\providecommand|，以及 |\NewDocumentCommand| 等命令（有关这些命令的详细
信息，请参阅 \texttt{usrguide}）。

当定义环境时，请使用 |\NewDocumentEnvironment| 等命令（对于简单情况也可以使
用 |\newenvironment| 等），而不是使用 |\def\foo{...}| 和 |\def\endfoo{...}|。

如果需要设置或更改 \m{dimen} 或 \m{skip} 寄存器的值，请使用 |\setlength|。

要操作盒子，请使用诸如 |\sbox|、|\mbox| 和 |\parbox| 等 \LaTeX{} 命令，而
不是 |\setbox|、|\hbox| 和 |\vbox|。

使用 |\PackageError|、|\PackageWarning| 或 |\PackageInfo|（或相应的类命令），
而不是 |\@latexerr|、|\@warning| 或 |\wlog|。

这种做法的优点是您的代码更易读，并且更容易让其他有经验的 \LaTeX{} 程序员理解。

\subsubsection{增强可移植性}

使您的文件尽可能具有可移植性也是明智的。为了确保这一点，文件不能与标准
\LaTeX{} 发行版中的文件同名，即使其内容可能与这些文件之一非常相似也不行。
而且，最好仍然只使用 ASCII 范围内的文件名：尽管 \LaTeX{} 原生支持 UTF-8，
但并不能肯定所有工具都支持。出于同样的原因，避免文件名中出现空格。

如果本地的文档类或宏包有一个共同的前缀，例如 Nowhere 大学的类可能以 |unw|
开头。这有助于避免每个大学都拥有自己的名为 |thesis.cls| 的论文类。

如果您依赖于 \LaTeX{} 核心的某些功能，或者依赖于某个宏包，请指定您所需的
发布日期。例如，错误处理宏包是在 2022 年 6 月的发布中引入的，所以如果您使
用它们，应该加上：
\begin{verbatim}
   \NeedsTeXFormat{LaTeX2e}[2022-06-01]
\end{verbatim}

\subsubsection{有用的钩子}

有时候，一个宏包需要安排在导言区的开头或结尾、文档末尾或每次使用某个
环境的开头执行一些代码。这可以通过使用钩子来实现。作为文档作者，您可能
熟悉 |\AtBeginDocument|，它是一个对更强大的 |\AddToHook| 的包装。
\LaTeX{} 核心提供了大量专用钩子（应用于预定义位置）和通用钩子（适用于
任意命令）：使用这些钩子的接口在 \texttt{lthooks} 中有描述。还有用于
文件的钩子，在 \texttt{ltfilehooks} 中有描述。

\section{文档类或宏包的结构}
\label{Sec:structure}

文档类或宏包文件的大纲如下：
\begin{description}
   \item[标识] 文件声明自己是一个 \LaTeXe{} 宏包或文档类，并简要描述自身。
   \item[初步声明] 在这里，文件声明一些命令，并可以加载其他文件。
         通常，这些命令将只是声明所用选项中需要的代码。
   \item[选项] 文件声明并处理其选项。
   \item[更多声明] 这是文件执行大部分工作的地方：
         声明新变量、命令和字体；以及加载其他文件。
\end{description}

\subsection{标识}

文档类或宏包文件的第一件事是标识自己。宏包文件的标识如下：
\begin{verbatim}
   \NeedsTeXFormat{LaTeX2e}
   \ProvidesPackage{<package>}[<date> <other information>]
\end{verbatim}
例如：
\begin{verbatim}
   \NeedsTeXFormat{LaTeX2e}
   \ProvidesPackage{latexsym}[1998-08-17 Standard LaTeX package]
\end{verbatim}
文档类文件的标识如下：
\begin{verbatim}
   \NeedsTeXFormat{LaTeX2e}
   \ProvidesClass{<class-name>}[<date> <other information>]
\end{verbatim}
例如：
\begin{verbatim}
   \NeedsTeXFormat{LaTeX2e}
   \ProvidesClass{article}[2022-06-01 Standard LaTeX class]
\end{verbatim}
\m{date} 应以 `\textsc{yyyy-mm-dd}' 的形式给出，如果使用了可选参数，必
须存在（这对于 |\NeedsTeXFormat| 命令也是如此）。任何偏离此语法的情况都
会导致低级别的 \TeX{} 错误——这些命令期望有效的语法以加快宏包或文档类的
日常使用，并不考虑开发者犯错的情况！

每当用户在其 |\documentclass| 或 |\usepackage| 命令中指定日期时，都会检
查此日期。例如，如果您写了：
\begin{verbatim}
   \documentclass{article}[2022-06-01]
\end{verbatim}
那么在不同位置的用户会收到警告，指出他们的 |article| 副本已过时。

当使用类时，类的描述会显示出来。宏包的描述会被放入日志文件中。这些描述也
会被 |\listfiles| 命令显示。短语 \texttt{Standard LaTeX} \textbf{绝对不应}
出现在除标准 \LaTeX{} 发行版之外的任何文件的标识中。

\subsection{使用类和宏包}

一个 \LaTeX{} 宏包或文档类可以加载另一个宏包，方法如下：
\begin{verbatim}
   \RequirePackage[<options>]{<package>}[<date>]
\end{verbatim}
例如：
\begin{verbatim}
   \RequirePackage{ifthen}[2022-06-01]
\end{verbatim}
此命令与作者命令 |\usepackage| 具有相同的语法。它允许宏包或文档类使用其他
宏包提供的功能。例如，通过加载 |ifthen| 宏包，宏包作者可以使用该宏包提供的
“if\dots then\dots else\dots” 命令。

一个 \LaTeX{} 文档类可以加载另一个类，方法如下：
\begin{verbatim}
   \LoadClass[<options>]{<class-name>}[<date>]
\end{verbatim}
例如：
\begin{verbatim}
   \LoadClass[twocolumn]{article}
\end{verbatim}
此命令与作者命令 |\documentclass| 具有相同的语法。它允许类基于另一个类的
语法和外观。例如，通过加载 |article| 类，类作者只需更改他们不喜欢的 |article|
的部分，而不是从头开始编写一个新的类。

以下命令可以在常见情况下使用，即您希望简单地加载一个具有当前类所使用的确切
选项的类或宏包文件。
\begin{verbatim}
   \LoadClassWithOptions{<class-name>}[<date>]
   \RequirePackageWithOptions{<package>}[<date>]
\end{verbatim}
例如：
\begin{verbatim}
   \LoadClassWithOptions{article}
   \RequirePackageWithOptions{graphics}[1995/12/01]
\end{verbatim}

\subsection{声明选项}

宏包和文档类可以声明选项，作者可以指定这些选项；例如，|twocolumn|
选项由 |article| 类声明。注意，选项的名称应仅包含“\LaTeX{} 名称”
中允许的字符；特别地，不能包含任何控制序列。

\LaTeX{} 支持两种创建选项的方法：键-值系统和“简单文本”方式。键-值系统
推荐用于新的类和宏包，并且在处理选项类方面比简单文本方式更灵活。这两种
选项方法在 \LaTeX{} 源文件中使用相同的基本结构：首先声明选项，然后在第
二步处理选项。两者都允许将选项传递给其他宏包或底层类。由于“经典”的简
单文本方式在概念上更直观，用于展示一般结构；详细的键-值方法请参阅第
\ref{Sec:opt:keyval} 节。

声明一个选项如下：
\begin{verbatim}
   \DeclareOption{<option>}{<code>}
\end{verbatim}
例如，|graphics| 宏包中的 |dvips| 选项（略作简化）的实现如下：
\begin{verbatim}
   \DeclareOption{dvips}{\input{dvips.def}}
\end{verbatim}
这意味着当作者写 |\usepackage[dvips]{graphics}| 时，文件 |dvips.def|
会被加载。再举个例子，|article| 类中声明了 |a4paper| 选项以设置
|\paperheight| 和 |\paperwidth| 长度：
\begin{verbatim}
   \DeclareOption{a4paper}{%
      \setlength{\paperheight}{297mm}%
      \setlength{\paperwidth}{210mm}%
   }
\end{verbatim}
有时用户会请求类或宏包未明确声明的选项。默认情况下，这将产生警告（对
于类）或错误（对于宏包）；此行为可以通过以下方式更改：
\begin{verbatim}
   \DeclareOption*{<code>}
\end{verbatim}
例如，为使宏包 |fred| 对未知选项产生警告而不是错误，您可以指定：
\begin{verbatim}
   \DeclareOption*{%
      \PackageWarning{fred}{Unknown option `\CurrentOption'}%
   }
\end{verbatim}
这样，如果作者写了 |\usepackage[foo]{fred}|，他们会收到警告
\texttt{Package fred Warning: Unknown option `foo'.} 再举个例子，|fontenc|
宏包在使用 \m{ENC} 选项时会尝试加载文件 |<ENC>enc.def|。这可以通过如下
方式完成：
\begin{verbatim}
   \DeclareOption*{%
      \input{\CurrentOption enc.def}%
   }
\end{verbatim}

可以使用 |\PassOptionsToPackage| 或 |\PassOptionsToClass| 命令将选项传递
给另一个宏包或类（请注意，这是一种专门的操作，仅适用于选项名称）：
请参阅第 \ref{Sec:opmove} 节。例如，要将每个未知选项传递给 |article|
类，可以使用：
\begin{verbatim}
   \DeclareOption*{%
      \PassOptionsToClass{\CurrentOption}{article}%
   }
\end{verbatim}
如果这样做，您应该确保在稍后某个时刻加载该类，否则选项将永远不会被处
理！

到目前为止，我们只解释了如何声明选项，而不是如何执行它们。要处理文件调
用时使用的选项，应使用：
\begin{verbatim}
   \ProcessOptions\relax
\end{verbatim}
这将为每个已指定和已声明的选项执行相应的 \m{code}（请参阅第
\ref{Sec:commands.options} 节以了解详细信息）。

例如，如果 |jane| 宏包文件包含：
\begin{verbatim}
   \DeclareOption{foo}{\typeout{Saw foo.}}
   \DeclareOption{baz}{\typeout{Saw baz.}}
   \DeclareOption*{\typeout{What's \CurrentOption?}}
   \ProcessOptions\relax
\end{verbatim}
并且作者写了 |\usepackage[foo,bar]{jane}|，那么他们将看到消息
\texttt{Saw foo.} 和 \texttt{What's bar?}。

\subsection{一个最小的文档类文件}

一个文档类或宏包的大部分工作在于定义新命令或更改文档的外观。这是在
文档类的主体中完成的，使用诸如 |\newcommand| 或 |\setlength| 等命令。

每个文档类文件\emph{必须}包含四个内容：定义 |\normalsize|、设置
|\textwidth| 和 |\textheight| 的值，以及指定页码。因此，一个最小的文档
类文件\footnote{这个类现在已经在标准发行版中，名为 \texttt{minimal.cls}。}
看起来像这样：
\begin{verbatim}
   \NeedsTeXFormat{LaTeX2e}
   \ProvidesClass{minimal}[2022-06-01 Standard LaTeX minimal class]
   \renewcommand{\normalsize}{\fontsize{10pt}{12pt}\selectfont}
   \setlength{\textwidth}{6.5in}
   \setlength{\textheight}{8in}
   \pagenumbering{arabic}       % 即使这个类不显示页码也需要
\end{verbatim}
然而，这个类文件不支持脚注、边注、浮动对象等，也不提供像 |\rm| 这样
的两个字母的字体命令；因此，大多数文档类会包含比这更多的内容！

\subsection{示例：一个本地信函类}

一家公司可能有自己的信函类，用于按公司风格设置信函。本节展示了这
样一个类的简单实现，实际的类需要更多的结构。

该类首先以 |neplet.cls| 的身份宣布自己。
\begin{verbatim}
   \NeedsTeXFormat{LaTeX2e}
   \ProvidesClass{neplet}[2022-06-01 NonExistent Press letter class]
\end{verbatim}
然后，下面的部分将任何选项传递给 |letter| 类，并使用 |a4paper|
选项加载它。
\begin{verbatim}
   \DeclareOption*{\PassOptionsToClass{\CurrentOption}{letter}}
   \ProcessOptions\relax
   \LoadClass[a4paper]{letter}
\end{verbatim}
为了使用公司信头，重新定义了 |firstpage| 页样式：这是用于信函第一
页的页样式。
\begin{verbatim}
   \renewcommand{\ps@firstpage}{%
      \renewcommand{\@oddhead}{<letterhead goes here>}%
      \renewcommand{\@oddfoot}{<letterfoot goes here>}%
   }
\end{verbatim}
就是这样！

\subsection{示例：一个新闻简报类}

可以使用 \LaTeX{} 来排版简单的新闻简报，使用的是 |article| 类的变体。
该类首先以 |smplnews.cls| 的身份宣布自己。
\begin{verbatim}
   \NeedsTeXFormat{LaTeX2e}
   \ProvidesClass{smplnews}[2022-06-01 The Simple News newsletter class]

   \newcommand{\headlinecolor}{\normalcolor}
\end{verbatim}
它将大多数指定的选项传递给 |article| 类：除了 |onecolumn| 选项被关闭，
|green| 选项将标题设置为绿色。
\begin{verbatim}
   \DeclareOption{onecolumn}{\OptionNotUsed}
   \DeclareOption{green}{\renewcommand{\headlinecolor}{\color{green}}}

   \DeclareOption*{\PassOptionsToClass{\CurrentOption}{article}}

   \ProcessOptions\relax
\end{verbatim}
然后加载 |article| 类，使用 |twocolumn| 选项。
\begin{verbatim}
   \LoadClass[twocolumn]{article}
\end{verbatim}
由于新闻简报将以彩色打印，它现在加载 |color| 宏包。该类不指定设备驱动
程序选项，因为这应由 |smplnews| 类的使用者指定。
\begin{verbatim}
   \RequirePackage{color}
\end{verbatim}
然后重新定义 |\maketitle|，以 72\,pt Helvetica 粗斜体显示标题，使用合适
的颜色。
\begin{verbatim}
   \renewcommand{\maketitle}{%
      \twocolumn[%
         \fontsize{72}{80}\fontfamily{phv}\fontseries{b}%
         \fontshape{sl}\selectfont\headlinecolor
         \@title
      ]%
   }
\end{verbatim}
它重新定义了 |\section| 并关闭了章节编号。
\begin{verbatim}
   \renewcommand{\section}{%
      \@startsection
         {section}{1}{0pt}{-1.5ex plus -1ex minus -.2ex}%
         {1ex plus .2ex}{\large\sffamily\slshape\headlinecolor}%
   }

   \setcounter{secnumdepth}{0}
\end{verbatim}
它还设置了三个基本要素。
\begin{verbatim}
   \renewcommand{\normalsize}{\fontsize{9}{10}\selectfont}
   \setlength{\textwidth}{17.5cm}
   \setlength{\textheight}{25cm}
\end{verbatim}
在实践中，一个类需要比这更多：它将提供用于期号、文章作者、页面样式等的命
令；但是这个框架已经提供了一个开始。|ltnews| 类文件和这个类文件相比也没
有更复杂多少。

\section{用于类和宏包编写者的命令}
\label{Sec:commands}

本节简要描述了用于类和宏包编写者的每个命令。要了解系统的其他方面，
您还应阅读 《\LaTeXbook》、《\LaTeXcomp》 和 《\usrguide》。

\subsection{识别}

首先讨论的一组命令是用于识别您的类或宏包文件的命令。

\begin{decl}
   |\NeedsTeXFormat| \arg{format-name} \oarg{release-date}
\end{decl}
该命令告诉 \TeX{} 应使用名称为 \m{format-name} 的格式处理此文件。您
可以使用可选参数 \m{release-date} 进一步指定所需格式的最早发布日期。
当格式的发布日期早于指定的日期时，将生成警告。标准的 \m{format-name}
是 \texttt{LaTeX2e}。如果存在日期，则必须采用 \textsc{yyyy-mm-dd} 的
形式。

示例：
\begin{verbatim}
   \NeedsTeXFormat{LaTeX2e}[2022-06-01]
\end{verbatim}

\begin{decl}
   |\ProvidesClass| \arg{class-name} \oarg{release-info} \\
   |\ProvidesPackage| \arg{package-name} \oarg{release-info}
\end{decl}
此声明当前文件包含文档类 \m{class-name} 或宏包 \m{package-name} 的定义。

可选的 \m{release-info}，如果使用，必须包含：
\begin{itemize}
   \item 此版本文件的发布日期，形式为 \textsc{yyyy-mm-dd}；
   \item 可选地跟着一个空格和一个简短描述，可能包括版本号。
\end{itemize}
上述语法必须严格遵循，以便 |\LoadClass| 或 |\documentclass|（对于类）
或 |\RequirePackage| 或 |\usepackage|（对于宏包）测试发布是否太旧。

整个 \m{release-info} 信息将由 |\listfiles| 显示，因此不应太长。

示例：
\begin{verbatim}
   \ProvidesClass{article}[2022-06-01 v1.0 Standard LaTeX class]
   \ProvidesPackage{ifthen}[2022-06-01 v1.0 Standard LaTeX package]
\end{verbatim}

\begin{decl}
   |\ProvidesFile| \arg{file-name} \oarg{release-info}
\end{decl}
这类似于前两个命令，只是这里必须给出完整的文件名，包括扩展名。用于
声明除主类和宏包文件以外的任何文件。

示例：
\begin{verbatim}
   \ProvidesFile{T1enc.def}[2022-06-01 v1.0 Standard LaTeX file]
\end{verbatim}

请注意，在除了标准 \LaTeX{} 发行版之外的任何文件的标识横幅中，
\texttt{Standard LaTeX} \textbf{绝不能} 使用。

\subsection{加载文件}
\label{Sec:loadf}

这组命令可用于通过基于现有类或宏包来创建自己的文档类或宏包。

\begin{decl}
   |\RequirePackage| \oarg{options-list} \arg{package-name}
   \oarg{release-info}\\
   |\RequirePackageWithOptions| \arg{package-name}
   \oarg{release-info}
\end{decl}
宏包和文档类应使用这些命令加载其他宏包。

使用 |\RequirePackage| 与作者命令 |\usepackage| 相同。
示例：
\begin{verbatim}
   \RequirePackage{ifthen}[2022-06-01]
   \RequirePackageWithOptions{graphics}[2022-06-01]
\end{verbatim}

\begin{decl}
   |\LoadClass| \oarg{options-list} \arg{class-name}
   \oarg{release-info}\\
   |\LoadClassWithOptions| \arg{class-name}
   \oarg{release-info}
\end{decl}
这些命令仅用于类文件中，不能用于宏包文件；在类文件中最多只能使用一次。

使用 |\LoadClass| 与使用 |\documentclass| 加载类文件相同。

示例：
\begin{verbatim}
   \LoadClass{article}[2022-06-01]
   \LoadClassWithOptions{article}[2022-06-01]
\end{verbatim}

两个带 |WithOptions| 的版本仅加载具有当前文件（类或宏包）使用的选项的类
（或宏包）文件。有关其用法的进一步讨论，请参见下文，\ref{Sec:opmove} 节。

\subsection{延迟代码}
\label{Sec:delays}

如前所述，\texttt{lthooks} 中提供了一个复杂的钩子系统。这里我们记录了一
小组常见钩子的便捷简短名称。

这前两个命令也主要用于 |\DeclareOption| 或 |\DeclareOption*| 的 \m{code}
参数内。

\begin{decl}
   |\AtEndOfClass| \arg{code}\\
   |\AtEndOfPackage| \arg{code}
\end{decl}
这些命令声明了 \m{code}，会在整个当前类或宏包文件处理完毕后保存并执行。

允许重复使用这些命令：参数中的代码按声明顺序存储（并后续执行）。

\begin{decl}
   |\AtBeginDocument| \arg{code}\\
   |\AtEndDocument| \arg{code}
\end{decl}
这些命令声明了将在 \LaTeX{} 执行 |\begin{document}| 或 |\end{document}|
期间保存并执行的 \m{code}。

|\AtBeginDocument| 中的参数指定的 \m{code} 在 |\begin{document}| 代码的末
尾执行，\emph{在}设置字体选择表之后。因此，这是放置需要在所有内容准备好
进行排版，并且正常字体为当前字体时执行的代码的有用位置。

|\AtBeginDocument| 钩子不应用于进行任何排版，因为排版结果将是不可预测的。

|\AtEndDocument| 中的参数指定的 \m{code} 在 |\end{document}| 代码的开头执
行，\emph{在}最终页面完成之前，也在处理任何剩余的浮动环境之前。如果某些
\m{code} 需要在这两个过程之后执行，应在 \m{code} 的适当位置包含 |\clearpage|。

允许重复使用这些命令：参数中的代码按声明顺序存储（并后续执行）。

\subsection{创建和使用键值选项}
\label{Sec:opt:keyval}

与任何键-值输入一样，使用键-值对作为宏包或类选项有两部分：创建键选项和设置（使用）它们。
以这种方式创建的选项 \emph{可能} 作为一般键-值设置在加载宏包后使用：这将取决于底层代码的性质。

\begin{decl}
   |\DeclareKeys| \oarg{family} \arg{declarations}
\end{decl}
此命令从逗号分隔的 \m{declarations} 列表中创建一系列选项。列表中的每个条目都是键-值对，
其中 \m{key} 具有一个或多个 \m{properties}。下面介绍了一小部分“基本”的
\m{properties}。由 \texttt{l3keys} 提供的完整范围的属性也可用于更强大的处理。
有关完整细节，请参见 \texttt{interface3}。

这里提供的基本属性包括：
\begin{itemize}
   \item \texttt{.code} --- 执行任意代码
   \item \texttt{.if} --- 设置一个 \TeX{} |\if...| 开关
   \item \texttt{.ifnot} --- 设置一个反转的 \TeX{} |\if...| 开关
   \item \texttt{.store} --- 将值存储到宏中
   \item \texttt{.usage} -- 定义选项是否仅能在加载时使用（\texttt{load}）、在导言区使用
         （\texttt{preamble}）或在范围上没有限制（\texttt{general}）
\end{itemize}
在 \m{property} 之前的 \meta{key} 部分是 \m{name}，\m{value} 与 \m{property} 一起定义了
选项的行为。

例如，使用以下声明：
\begin{verbatim}
\DeclareKeys[mypkg]
 {
   draft.if          = @mypkg@draft      ,
   draft.usage       = preamble          ,
   name.store        = \@mypkg@name      ,
   name.usage        = load              ,
   second-name.store = \@mypkg@other@name
 }
\end{verbatim}
将创建三个选项。选项 \texttt{draft} 可以在导言区的任何位置给出，并将设置一个名为 |\if@mypkg@draft|
的开关。
选项 \texttt{name} 只能在加载宏包时给出，并将保存给定的任何值到 |\@mypkg@name| 中。最后，选项
\texttt{second-name} 可以在任何位置给出，并将其值保存到 |\@mypkg@other@name| 中。

在使用 |\ProcessKeyOptions| 之前创建的键将作为宏包选项。

\begin{decl}
   |\DeclareUnknownKeyHandler| \oarg{family} \arg{code}
\end{decl}
命令 |\DeclareUnknownKeyHandler| 用于定义遇到未定义键时的行为。参数 \m{code} 将接收未知键名为
|#1|，值为 |#2|。
然后可以根据需要处理它们，例如将其转发到另一个宏包。整个选项作为 \cs{CurrentOption} 可用，如果
需要传递可能包含 |=| 符号的选项。
例如，这可用于将未知选项传递给 \pkg{article} 等非键值类：
\begin{verbatim}
\DeclareUnknownKeyHandler{%
  \PassOptionsToClass{\CurrentOption}{article}
}
\end{verbatim}

\begin{decl}
   |\ProcessKeyOptions| \oarg{family}
\end{decl}
函数 |\ProcessKeyOptions| 用于检查当前选项列表与 \m{family} 定义的键。在包中调用此函数时将
检查全局（类）选项和局部（宏包）选项。该命令将处理当前宏包或类给定的\emph{所有}选项：不需要
额外应用 \cs{ProcessOptions}。

\begin{decl}
   |\SetKeys| \oarg{family} \arg{keyvals}
\end{decl}
为 \m{family} 设置（应用）显式的 \m{keyvals} 列表：如果未给出后者，则使用 |\@currname|
的值。此命令可用于在使用 |\ProcessKeyOptions| 之前或之后在宏包中设置选项。

\subsection{选项传递}
\label{Sec:opmove}

这两个命令也在选项的 \m{code} 参数中非常有用。
\begin{decl}
   |\PassOptionsToPackage| \arg{options-list} \arg{package-name}\\
   |\PassOptionsToClass| \arg{options-list} \arg{class-name}
\end{decl}
命令 |\PassOptionsToPackage| 将 \m{options-list} 中的选项名称传递给宏包 \m{package-name}。
这意味着它将 \m{option-list} 添加到任何未来对宏包 \m{package-name} 的 |\RequirePackage|
或 |\usepackage| 命令所使用的选项列表中。

示例：
\begin{verbatim}
   \PassOptionsToPackage{foo,bar}{fred}
   \RequirePackage[baz]{fred}
\end{verbatim}
等同于：
\begin{verbatim}
   \RequirePackage[foo,bar,baz]{fred}
\end{verbatim}

类似地，|\PassOptionsToClass| 可以在类文件中用于将选项传递给另一个要由 |\LoadClass| 加载的类。

这两个命令的效果和用法应与上文（\ref{Sec:loadf}）中的以下两个命令进行对比：
\begin{verbatim}
   \LoadClassWithOptions
   \RequirePackageWithOptions
\end{verbatim}
命令 |\RequirePackageWithOptions| 类似于 |\RequirePackage|，但它始终使用与当前类或宏包使用
的选项列表完全相同的选项列表加载所需的包，而不是使用由 |\PassOptionsToPackage| 明确提供或传递
的选项。

|\LoadClassWithOptions| 的主要目的是允许一个类简单地建立在另一个类之上，例如：
\begin{verbatim}
  \LoadClassWithOptions{article}
\end{verbatim}
这应该与略有不同的构造进行比较：
\begin{verbatim}
  \DeclareOption*{\PassOptionsToClass{\CurrentOption}{article}}
  \ProcessOptions\relax
  \LoadClass{article}
\end{verbatim}
如上所用，效果几乎相同，但第一个命令要输入的内容较少；同时，\hfil\break
|\LoadClassWithOptions| 方法稍微更快一些。

然而，如果类声明了自己的选项，则这两种构造是不同的。例如比较：
\begin{verbatim}
  \DeclareOption{landscape}{\@landscapetrue}
  \ProcessOptions\relax
  \LoadClassWithOptions{article}
\end{verbatim}
和：
\begin{verbatim}
  \DeclareOption{landscape}{\@landscapetrue}
  \DeclareOption*{\PassOptionsToClass{\CurrentOption}{article}}
  \ProcessOptions\relax
  \LoadClass{article}
\end{verbatim}
在第一个示例中，只有当当前类以此选项调用时，\textsf{article} 类将使用选项 |landscape| 加载。
相比之下，第二个示例中，它永远不会使用选项 |landscape|，因为在这种情况下，\textsf{article}
仅通过默认选项处理程序传递选项，但该处理程序不用于 |landscape|，因为该选项已明确声明。

\subsection{安全文件命令}

这些命令处理文件输入；它们确保以用户友好的方式处理请求的文件不存在的情况。

\begin{decl}
   |\IfFileExists| \arg{file-name} \arg{true} \arg{false}
\end{decl}
如果文件存在，则执行 \m{true} 中指定的代码。

如果文件不存在，则执行 \m{false} 中指定的代码。

此命令\emph{不会}输入文件。

\begin{decl}
   |\InputIfFileExists| \arg{file-name} \arg{true} \arg{false}
\end{decl}
如果文件存在，则输入文件 \m{file-name}，并在输入之前立即执行 \m{true} 中指定的代码。

如果文件不存在，则执行 \m{false} 中指定的代码。

它是使用 |\IfFileExists| 实现的。

\subsection{报告错误等}

这些命令应由第三方类和宏包用于报告错误或向作者提供信息。

\begin{decl}
   |\ClassError| \arg{class-name} \arg{error-text} \arg{help-text}\\
   |\PackageError| \arg{package-name} \arg{error-text} \arg{help-text}
\end{decl}
这些命令产生一个错误消息。显示 \m{error-text}，并显示 |?| 错误提示符。如果用户键入
|h|，则会显示 \m{help-text}。

在 \m{error-text} 和 \m{help-text} 中：|\protect| 可用于阻止命令展开；\hfil\break
|\MessageBreak| 导致换行；|\space| 打印空格。

请注意，\m{error-text} 将添加一个句号，因此不要在参数中放入句号。

例如：
\begin{verbatim}
   \newcommand{\foo}{FOO}
   \PackageError{ethel}{%
      Your hovercraft is full of eels,\MessageBreak
      and \protect\foo\space is \foo
   }{%
      Oh dear! Something's gone wrong.\MessageBreak
      \space \space Try typing \space <<return>>
      \space to proceed, ignoring \protect\foo.
   }
\end{verbatim}
将显示：
\begin{verbatim}
   ! Package ethel Error: Your hovercraft is full of eels,
   (ethel)                and \foo is FOO.

   See the ethel package documentation for explanation.
\end{verbatim}
如果用户键入 |h|，则将显示：
\begin{verbatim}
   Oh dear! Something's gone wrong.
     Try typing  <<return>>  to proceed, ignoring \foo.
\end{verbatim}

\begin{decl}
   |\ClassWarning| \arg{class-name} \arg{warning-text}\\
   |\PackageWarning| \arg{package-name} \arg{warning-text}\\
   |\ClassWarningNoLine| \arg{class-name} \arg{warning-text}\\
   |\PackageWarningNoLine| \arg{package-name} \arg{warning-text}\\
   |\ClassInfo| \arg{class-name} \arg{info-text}\\
   |\PackageInfo| \arg{package-name} \arg{info-text}
\end{decl}
四个 |Warning| 命令类似于错误命令，但仅在屏幕上产生警告，没有错误提示。

前两个 |Warning| 版本还显示发生警告的行号，而后两个 |WarningNoLine| 版本不显示行号。

两个 |Info| 命令类似，但仅在传输文件中记录信息，包括行号。这两个命令没有 |NoLine| 版本。

在 \m{warning-text} 和 \m{info-text} 中：|\protect| 可用于阻止命令展开；
|\MessageBreak| 导致换行；|\space| 打印空格。同时，这些内容不应该以句号结尾，因为会
自动添加。

\section{杂项命令等}
\label{Sec:commands.misc}

\subsection{版面参数}

\begin{decl}
   |\paperheight|\\
   |\paperwidth|
\end{decl}
这两个参数通常由文档类设置为所使用的纸张尺寸。这应该是实际的纸张尺寸，不同于 |\textwidth|
和 |\textheight|，它们是页面边距内主文本区域的尺寸。

\subsection{大小写转换}
\label{sec:case}

\begin{decl}
   |\MakeUppercase| \arg{text} \\
   |\MakeLowercase| \arg{text} \\
   |\MakeTitlecase| \arg{text}
\end{decl}

如 \texttt{usrguide} 所述，对文本进行大小写转换应使用命令 |\MakeUppercase|、
|\MakeLowercase| 和 |\MakeTitlecase|。如果需要更改编程材料的大小写，团队强烈建议使用
\texttt{str} 模块中 L3 编程层的命令。如果不希望这样做，在这种情况下应仅使用 \TeX{} 的
|\uppercase| 和 |\lowercase| 原语。

\subsection{更好的用户定义的数学显示环境}

\begin{decl}
   |\ignorespacesafterend|
\end{decl}

假设你想定义一个以方程编号的文本显示环境。一个直接的方法是：
\begin{verbatim}
  \newenvironment{texteqn}
    {\begin{equation}
       \begin{minipage}{0.9\linewidth}}
      {\end{minipage}
     \end{equation}}
\end{verbatim}
然而，如果你尝试过，你可能会注意到在段落中使用时并不完美，因为在环境之后的第一行开头会出现
单词间的空格。

你可以使用 |\ignorespacesafterend| 避免这个问题；它应该如下所示插入：
\begin{verbatim}
  \newenvironment{texteqn}
    {\begin{equation}
       \begin{minipage}{0.9\linewidth}}
      {\end{minipage}
     \end{equation}
     \ignorespacesafterend}
\end{verbatim}

此命令可能还有其他用途。

\subsection{规范化间距}

\begin{decl}
   |\normalsfcodes|
\end{decl}

应该使用此命令来恢复影响单词间、句子间等间距的参数的正常设置。

这个特性的一个重要用途是纠正 Donald Arseneau 报告的问题，在局部设置空格代码生效时，
页面标题中的标点可能出现问题。这些空格代码会被改变，比如由命令 \verb|\frenchspacing|
和 \textsf{verbatim} 环境引起。

通常在 |\begin{document}| 中会自动给出正确的定义，所以不需要显式设置；但是，如果在
类文件中显式地使其非空，则默认的自动设置将被覆盖。

\subsection{查询本地化信息}

自定义一系列输出需要本地化信息。\LaTeX{} 核心本身不管理本地化，而是由 \pkg{babel} 和
\pkg{polyglossia} 来提供良好的支持。为了允许核心和其他宏包访问由 \pkg{babel} 或
\pkg{polyglossia} 提供的当前本地化信息，核心定义了命令 \cs{BCPdata}。初始核心定义会
扩展到 \texttt{en-US} 的标记部分，因为核心不追踪本地化，但是会使用基本的美国英语设置。
但是，如果加载了 \pkg{babel} 或 \pkg{polyglossia}，它会重新定义为相应包中的 BCP-47
信息。支持的参数是 BCP-47 标记的拆分：
\begin{itemize}
   \item \texttt{tag} 完整的 BCP-47 标记（例如 \texttt{en-US}）
   \item \texttt{language}（例如 \texttt{de}）
   \item \texttt{region}（例如 \texttt{AT}）
   \item \texttt{script}（例如 \texttt{Latn}）
   \item \texttt{variant}（例如 \texttt{1901}）
   \item \texttt{extension.t}（转换，例如 \texttt{en-t-ja}）
   \item \texttt{extension.u}（附加区域信息，例如 \texttt{ar-u-nu-latn}）
   \item \texttt{extension.x}（私有使用区域，例如 \texttt{la-x-classic}）
\end{itemize}
如果这些参数以 \texttt{main.} 为前缀，则会提供文档的\emph{主要}语言信息，例如
\texttt{main.language} 将扩展为主要语言，即使当前活动的语言是其他语言也是如此。

除了标记拆分，还支持以下语义参数
\begin{itemize}
   \item \texttt{casing} 用于更改大小写的标记，例如 \texttt{el-x-iota} 可以被选择，
         而不是 \texttt{el}，以在大写时选择大写 adscript iota 的希腊字母
\end{itemize}

例如，大小写转换命令 \cs{MakeUppercase} 的（概念上的）定义如下：
\begin{verbatim}
\ExpandArgs{e}\MakeUppercaseAux{\BCPdata{casing}}{#1}
\end{verbatim}
其中 |#1| 是用户输入，\cs{MakeUppercaseAux} 的第一个参数接受两个参数，即地区和输入文本。

\subsection{属性的扩展和可扩展引用}

属性是 \LaTeX{} 在处理文档时可以追踪的内容，比如页面编号、标题编号、其他计数器数值、标题名称、
页面位置等等。这类属性的当前值可以被标记并写入 \texttt{aux} 文件。然后在下一次编译时，可以像
标准的 \cs{label}/\cs{ref} 命令一样引用这些值（它们记录/引用一组固定的属性：标签、页面、标题
和目标）。

\begin{decl}
   |\RecordProperties|\arg{label}\arg{list of properties}
\end{decl}
这个命令将\meta{list of properties}的值写入 \texttt{aux} 文件，并标记为\meta{label}。记录的值要么是在
调用 \cs{RecordProperties} 时的当前值，要么是在下次输出时的当前值——这取决于每个属性的声明方式。
%
\meta{label}和\meta{list of properties}中的参数可以包含被展开的命令。虽然\meta{label}可以展开为任意字符串
（只要它可以安全地写入 \texttt{aux} 文件），但需要注意的是 \cs{label} 和 \cs{RecordProperties}
的标签名共享一个命名空间。这意味着使用以下代码会收到 \texttt{Label `A'  multiply defined}的警告：
\begin{verbatim}
\label{A}\RecordProperties{A}{abspage}
\end{verbatim}

\begin{decl}
   |\RefProperty|\arg{label}\arg{property}
\end{decl}
这个命令允许引用在上一次运行时记录并被\meta{label}标记的\meta{property}的值。与标准的 \cs{ref} 命令不同，
这个命令是可展开的，并且该值可以例如——如果是数字——在赋值中使用。\footnote{为了使其工作，属性的默认值
   也需要是一个数字，因为在第一次 \LaTeX{} 运行时无法得知记录的值。}

\begin{verbatim}
\section{A section}
\RecordProperties{mylabel}{pagenum,counter}
\RefProperty{mylabel}{counter} % 输出章节
\setcounter{mycounter}{\RefProperty{mylabel}{pagenum}} 
\end{verbatim}

由于 \cs{RefProperty} 是可展开的，如果找不到标签，它将不会发出重新运行的警告。如果需要，可以通过
以下命令强制发出这样的警告：
\begin{decl}
   |\RefUndefinedWarn|\arg{label}\arg{property}
\end{decl}

\LaTeX{} 预定义了一组属性，这个集合也包括标准 \cs{label} 命令存储的属性。在下面的列表中，“默认”
表示当值尚未知道时返回的值（即，如果它在上一次运行中没有被记录并在输出时），“在输出时”表示该属性在使用
\cs{RecordProperties} 时不会立即记录，而是在下一个输出时记录。

\begin{description}
   \item[\texttt{abspage}（默认值：\texttt{0}，在输出时）] 当前页面的绝对值：从 $1$ 开始并在每次
         输出时单调递增。

   \item[\texttt{page}（默认值：\texttt{0}，在输出时）] 由 \cs{thepage} 给出的当前页面：这可能是
         一个数字值，也可能不是，这取决于当前的样式。与 \texttt{abspage} 相对比。你也可以用标准的
         \cs{label}/\cs{pageref} 得到这个值。

   \item[\texttt{pagenum}（默认值：\texttt{0}，在输出时）] 当前页面的阿拉伯数字。这适用于整数操作
         和比较。

   \item[\texttt{label}（默认值：\texttt{??}）] \cs{@currentlabel} 的内容。这就是你使用标准的
         \cs{label}/\hfil\break\cs{ref} 得到的值。

   \item[\texttt{title}（默认值：\texttt{\cs{textbf}\{??\}}）] \cs{@currentlabelname} 的内容。
         这个命令由 \pkg{nameref} 包和一些类（例如 \pkg{memoir}）填充，通常给出文档中由某些节命令
         定义的标题。

   \item[\texttt{target}（默认值：\meta{\mdseries empty}）] \cs{@currentHref} 的内容。这个命令
         通常由 \pkg{hyperref} 填充，并保存它所创建的最后一个目标的名称。

   \item[\texttt{pagetarget}（默认值：\meta{\mdseries empty}，在输出时）] \cs{@currentHpage}
         的内容。这个命令由 \pkg{hyperref}（版本 v7.01c 或更新）填充，并保存它所创建的最后一个页面
         锚点的名称。

   \item[\texttt{counter}（默认值：\meta{\mdseries empty}）] \cs{@currentcounter} 的内容。这个
         命令在\hfil\break \cs{refstepcounter} 后包含计数器的名称。

   \item[\texttt{xpos}、\texttt{ypos}（默认值：\texttt{0}，在输出时）] 这些属性记录了先前使用
         \cs{pdfsavepos}\hfil\break/\cs{savepos} 存储的一个点的 $x$ 和 $y$ 坐标。例如（如果使用
         了 \pkg{bidi}，可能需要在标签之前和之后保存位置）：

         \begin{verbatim}
     \pdfsavepos 
     \RecordProperties{myposition}{xpos,ypos}%
     \pdfsavepos
   \end{verbatim}
\end{description}

类和宏包的作者可以定义更多属性来存储他们感兴趣的其他值。
\begin{decl}
   |\NewProperty|\arg{name}\arg{setpoint}\arg{default}\arg{code}\\
   |\SetProperty|\arg{name}\arg{setpoint}\arg{default}\arg{code}
\end{decl}
这些命令声明或更改一个属性 \meta{name}\footnote{只更改你声明过的属性。绝对不要更改 \LaTeX{} 的标准
   属性和其他包的属性声明！}。如果在一个包中声明一个新的属性，建议将其命名为\meta{package-name}\texttt{/}
\meta{property-name}。 \meta{setpoint} 是 \texttt{now} 或 \texttt{shipout}，决定值是直接写入还是在下次
输出时写入。如果属性被引用但尚未知道，则使用\meta{default}，例如，在第一次运行时。 \meta{code} 是存
储值时执行的代码。例如，\texttt{pagenum} 属性被声明为：
\begin{verbatim}
\NewProperty{pagenum}{shipout}{0}{\the\value{page}}
\end{verbatim}

与属性相关的命令提供了一组传统 \LaTeXe{} 包的驼峰命令（如果需要，可以在文档导言部分使用）以及现代包
的 \texttt{expl3} 命令，它们使用了 \LaTeX{} 的 L3 编程层。 \texttt{expl3} 命令和更多细节可以在
\texttt{ltproperties-doc.pdf} 中找到。

\subsection{准备链接目标}

文档中的活动链接需要跳转到的目标。这些目标通常是自动创建的（如果加载了 \pkg{hyperref} 包），
通过 \cs{refstepcounter} 命令实现。但也存在类或包的作者需要手动添加目标的情况，
例如，在无编号的节命令或环境中。为此，\LaTeX{} 提供了以下命令。在 \emph{无}
\pkg{hyperref} 的情况下，它们不会执行任何操作或者仅插入一个 whatsits（确保在加载 hyperref 时不会更改间距）；
在 \emph{有} \pkg{hyperref} 的情况下，它们会添加必要的目标。有关以下命令的行为和参数的详细信息，
可以在 \pkg{hyperref} 包的 \texttt{hyperref-linktarget.pdf} 中找到。

\begin{decl}
   |\MakeLinkTarget|\oarg{prefix}\arg{counter}\\
   |\MakeLinkTarget|\oarg{prefix}\{\}\\
   |\MakeLinkTarget|*\arg{target name}
\end{decl}
这个命令准备创建目标。

\begin{decl}
   |\LinkTargetOn|\\
   |\LinkTargetOff|
\end{decl}
这些命令允许在局部启用和禁用目标的创建。这对于抑制通过 \cs{refstepcounter} 自动创建的目标非常有用。

\begin{decl}
   |\NextLinkTarget|\arg{target name}
\end{decl}
这会改变下一个将被创建的目标的名称。

\section{被新材料所取代的命令}

少量命令是在 \LaTeXe{} 于 1990 年代中期引入的，被广泛使用，但已被更现代的方法所取代。
这些命令在这里被介绍，因为它们很可能会在现有的类和包中被频繁遇到。

\subsection{定义命令}

这些命令的 \texttt{*} 形式应该用于定义在 \TeX{} 术语中不是长命令的命令。
这对于带有不打算包含整段文本的参数的命令进行错误捕获非常有用。

\begin{decl}
   |\DeclareRobustCommand| \arg{cmd} \oarg{num} \oarg{default}
   \arg{definition}\\
   |\DeclareRobustCommand*| \arg{cmd} \oarg{num} \oarg{default}
   \arg{definition}
\end{decl}
这个命令与 |\newcommand| 接受相同的参数，但它声明了一个强韧命令，即使 \m{definition} 中的某些代码是脆弱的。
你可以使用此命令来定义新的强韧命令，或重新定义现有命令并使其强韧。如果重新定义了一个命令，会在转录文件中放入日志。

例如，如果 |\seq| 定义如下：
\begin{verbatim}
   \DeclareRobustCommand{\seq}[2][n]{%
     \ifmmode
       #1_{1}\ldots#1_{#2}%
     \else
       \PackageWarning{fred}{You can't use \protect\seq\space in text}%
     \fi
   }
\end{verbatim}
那么命令 |\seq| 可以在移动参数中使用，即使 |\ifmmode| 不能，例如：
\begin{verbatim}
   \section{Stuff about sequences $\seq{x}$}
\end{verbatim}

还要注意，在定义的开头没有必要在 |\ifmmode| 前加上 |\relax|；
这是因为该 |\relax| 提供的保护，防止在错误的时候扩展，将在内部提供。

\begin{decl}
   |\CheckCommand| \arg{cmd} \oarg{num} \oarg{default}
   \arg{definition}\\
   |\CheckCommand*| \arg{cmd} \oarg{num} \oarg{default}
   \arg{definition}
\end{decl}
这与 |\newcommand| 接受相同的参数，但它不会定义 \m{cmd}，而是检查当前的 \m{cmd} 定义是否与 \m{definition} 完全相同。
如果这些定义不同，则会引发错误。

此命令对于在你的包开始更改命令定义之前检查系统状态非常有用。
特别是它允许你检查是否有其他包重新定义了相同的命令。

\subsection{选项声明}
\label{Sec:commands.options.dec}

以下命令处理文档类和包使用经典的“简单文本”方法声明和处理选项。
每个选项名称必须是一个“\LaTeX{} 名称”。

有一些命令特别设计用于这些命令的 \m{code} 参数中（见下文）。

\begin{decl}
   |\DeclareOption| \arg{option-name} \arg{code}
\end{decl}
这将 \m{option-name} 设为放置其中的类或包的“声明选项”。

\m{code} 参数包含了如果为该类或包指定了该选项时要执行的代码；
它可以包含任何有效的 \LaTeXe{} 结构。

示例：
\begin{verbatim}
   \DeclareOption{twoside}{\@twosidetrue}
\end{verbatim}

\begin{decl}
   |\DeclareOption*| \arg{code}
\end{decl}
这声明了一个对于每个为类或包指定但未显式声明的选项要执行的 \m{code}；
这段代码称为“默认选项代码”，它可以包含任何有效的 \LaTeXe{} 结构。

如果一个类文件没有包含 |\DeclareOption*|，那么默认情况下，为该类指定但未显式声明的所有选项将悄悄地传递给所有的包
（就像对于该类指定并声明的选项一样）。

如果一个包文件没有包含 |\DeclareOption*|，那么默认情况下，为该包指定但未显式声明的每个选项都将产生错误。

\subsection{选项代码中的命令}
\label{Sec:within.code}

这两个命令只能在 |\DeclareOption| 或 |\DeclareOption*| 的 \m{code} 参数中使用。
其他通常在这些参数中使用的命令可以在接下来的几个子节中找到。

\begin{decl}
   |\CurrentOption|
\end{decl}
这个命令展开为当前选项的名称。

\begin{decl}
   |\OptionNotUsed|
\end{decl}
这会将当前选项添加到“未使用选项”的列表中。

\subsection{选项处理}
\label{Sec:commands.options}

\begin{decl}
   |\ProcessOptions|
\end{decl}
这个命令会执行每个选择的选项的 \m{code}。

我们首先描述在包文件中 |\ProcessOptions| 的工作原理，然后介绍在类文件中的区别。

要详细了解在包文件中 |\ProcessOptions| 的工作原理，您需要了解“局部选项”和“全局选项”的区别。
\begin{itemize}
   \item \textbf{局部选项} 是在任何以下情况的 \m{options} 参数中为特定包明确指定的选项：
         \begin{quote}
            |\PassOptionsToPackage{<options>}| \ |\usepackage[<options>]|\\
            |\RequirePackage[<options>]|
         \end{quote}
   \item \textbf{全局选项} 是作者在 |\documentclass[<options>]| 的 \m{options} 参数中指定的其他选项。
\end{itemize}
例如，假设文档开头是：
\begin{verbatim}
   \documentclass[german,twocolumn]{article}
   \usepackage{gerhardt}
\end{verbatim}
而包 |gerhardt| 使用以下方式调用包 |fred|：
\begin{verbatim}
   \PassOptionsToPackage{german,dvips,a4paper}{fred}
   \RequirePackage[errorshow]{fred}
\end{verbatim}
那么：
\begin{itemize}
   \item |fred| 的局部选项是 |german|、|dvips|、|a4paper| 和 |errorshow|；
   \item |fred| 的全局选项只有 |twocolumn|。
\end{itemize}

当调用 |\ProcessOptions| 时，会发生以下情况。
\begin{itemize}
   \item \emph{首先}，对于 |fred.sty| 中到目前为止由 |\DeclareOption| 声明的每个选项，
         它会查看该选项是否是 |fred| 的全局或局部选项：如果是，就会执行相应的代码。

         这是按照这些选项在 |fred.sty| 中声明的顺序进行的。
   \item \emph{然后}，对于每个剩余的\emph{局部}选项，如果它已在某处定义（而不是由 |\DeclareOption| 定义），
         则会执行命令 |\ds@<option>|；否则，会执行“默认选项代码”。
         如果没有声明默认选项代码，则会产生错误消息。

         这是按照这些选项被指定的顺序进行的。
\end{itemize}
在整个过程中，系统确保对于一个选项，其声明的代码最多执行一次。

返回到示例，如果 |fred.sty| 包含以下内容：
\begin{verbatim}
   \DeclareOption{dvips}{\typeout{DVIPS}}
   \DeclareOption{german}{\typeout{GERMAN}}
   \DeclareOption{french}{\typeout{FRENCH}}
   \DeclareOption*{\PackageWarning{fred}{Unknown `\CurrentOption'}}
   \ProcessOptions\relax
\end{verbatim}
那么处理此文档的结果将是：
\begin{verbatim}
   DVIPS
   GERMAN
   Package fred Warning: Unknown `a4paper'.
   Package fred Warning: Unknown `errorshow'.
\end{verbatim}
请注意以下几点：

\begin{itemize}
   \item |dvips| 选项的代码在 |german| 选项之前执行，因为它们在 |fred.sty| 中声明的顺序是如此；
   \item 只有在处理声明的选项时，才会执行 |german| 选项的代码一次；
   \item |a4paper| 和 |errorshow| 选项产生了 |\DeclareOption*| 中声明的警告（按照它们被指定的顺序），而 |twocolumn| 选项没有：因为 |twocolumn| 是一个全局选项。
\end{itemize}

在类文件中，|\ProcessOptions| 的工作方式相同，除了：\emph{所有}选项都是局部的；而 |\DeclareOption*| 的默认值是 |\OptionNotUsed| 而不是错误。

请注意，因为 |\ProcessOptions| 有一个 |*| 形式，最好像前面的示例一样在非星号形式后面加上 |\relax|，这可以防止不必要的预读和可能引发误导性错误消息。

\begin{decl}
   |\ProcessOptions*|
\end{decl}
这与 |\ProcessOptions| 类似，但它按照调用命令中指定的顺序执行选项，而不是按照类或包中声明的顺序。对于包，这意味着首先处理全局选项。

\begin{decl}
   |\ExecuteOptions| \arg{options-list}
\end{decl}

它可用于在 |\ProcessOptions| 之前提供“默认选项列表”。例如，在类文件中，如果您希望设置默认设计为：双面打印；11pt 字体；两栏排版。那么可以这样指定：
\begin{verbatim}
   \ExecuteOptions{11pt,twoside,twocolumn}
\end{verbatim}

\end{document}
